<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Infocenter-TEST-V2
 *
 * Infocenter API test-v2
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.20
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Infocenter\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Infocenter\Client\ApiException;
use Infocenter\Client\Configuration;
use Infocenter\Client\HeaderSelector;
use Infocenter\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation administrativeAreaRegion
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeArea
     */
    public function administrativeAreaRegion($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->administrativeAreaRegionWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeArea, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeArea',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionAsync
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->administrativeAreaRegionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionAsyncWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegion'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling administrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionDailyForecast
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function administrativeAreaRegionDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionDailyForecastWithHttpInfo
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->administrativeAreaRegionDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionDailyForecastAsync
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionDailyForecastAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->administrativeAreaRegionDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionDailyForecast'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling administrativeAreaRegionDailyForecast'
            );
        }

        $resourcePath = '/areas/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionHourlyForecast
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function administrativeAreaRegionHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastWithHttpInfo
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->administrativeAreaRegionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastAsync
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->administrativeAreaRegionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionHourlyForecast'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling administrativeAreaRegionHourlyForecast'
            );
        }

        $resourcePath = '/areas/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionWeather
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function administrativeAreaRegionWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWeatherWithHttpInfo
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->administrativeAreaRegionWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionWeatherAsync
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionWeatherAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->administrativeAreaRegionWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionWeather'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling administrativeAreaRegionWeather'
            );
        }

        $resourcePath = '/areas/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation audioObject
     *
     * AudioObject
     *
     * @param  string $id Use property identifier of AudioObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAudioObject
     */
    public function audioObject($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->audioObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation audioObjectWithHttpInfo
     *
     * AudioObject
     *
     * @param  string $id Use property identifier of AudioObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAudioObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function audioObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAudioObject';
        $request = $this->audioObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAudioObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation audioObjectAsync
     *
     * AudioObject
     *
     * @param  string $id Use property identifier of AudioObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audioObjectAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->audioObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation audioObjectAsyncWithHttpInfo
     *
     * AudioObject
     *
     * @param  string $id Use property identifier of AudioObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function audioObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAudioObject';
        $request = $this->audioObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'audioObject'
     *
     * @param  string $id Use property identifier of AudioObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function audioObjectRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling audioObject'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling audioObject'
            );
        }

        $resourcePath = '/audioObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation category
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategory
     */
    public function category($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->categoryWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation categoryWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryAsync
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->categoryAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryAsyncWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'category'
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling category'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling category'
            );
        }

        $resourcePath = '/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoryTree
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoryTreeItem
     */
    public function categoryTree($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->categoryTreeWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation categoryTreeWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoryTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryTreeWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoryTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryTreeAsync
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsync($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->categoryTreeAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryTreeAsyncWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryTree'
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryTreeRequest($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling categoryTree'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling categoryTree'
            );
        }

        $resourcePath = '/categories/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructure
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructure
     */
    public function civicStructure($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->civicStructureWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation civicStructureWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructure, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureAsync
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->civicStructureAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureAsyncWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructure'
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructure'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling civicStructure'
            );
        }

        $resourcePath = '/civicStructures/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureDailyForecast
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function civicStructureDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureDailyForecastWithHttpInfo
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->civicStructureDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureDailyForecastAsync
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureDailyForecastAsyncWithHttpInfo
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->civicStructureDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureDailyForecast'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling civicStructureDailyForecast'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureHourlyForecast
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function civicStructureHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureHourlyForecastWithHttpInfo
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->civicStructureHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureHourlyForecastAsync
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureHourlyForecastAsyncWithHttpInfo
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->civicStructureHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureHourlyForecast'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling civicStructureHourlyForecast'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureWeather
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function civicStructureWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureWeatherWithHttpInfo
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->civicStructureWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureWeatherAsync
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureWeatherAsyncWithHttpInfo
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->civicStructureWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureWeather'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling civicStructureWeather'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation condition
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCondition
     */
    public function condition($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->conditionWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation conditionWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCondition, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCondition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionAsync
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->conditionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionAsyncWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'condition'
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling condition'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling condition'
            );
        }

        $resourcePath = '/conditions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionDailyForecast
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function conditionDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionDailyForecastWithHttpInfo
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->conditionDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionDailyForecastAsync
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionDailyForecastAsyncWithHttpInfo
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->conditionDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionDailyForecast'
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling conditionDailyForecast'
            );
        }

        $resourcePath = '/conditions/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionHourlyForecast
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function conditionHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionHourlyForecastWithHttpInfo
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->conditionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionHourlyForecastAsync
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionHourlyForecastAsyncWithHttpInfo
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->conditionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionHourlyForecast'
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling conditionHourlyForecast'
            );
        }

        $resourcePath = '/conditions/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionWeather
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function conditionWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionWeatherWithHttpInfo
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->conditionWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionWeatherAsync
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionWeatherAsyncWithHttpInfo
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->conditionWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionWeather'
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling conditionWeather'
            );
        }

        $resourcePath = '/conditions/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creativeWork
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCreativeWork
     */
    public function creativeWork($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->creativeWorkWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation creativeWorkWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCreativeWork, HTTP status code, HTTP response headers (array of strings)
     */
    public function creativeWorkWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWork';
        $request = $this->creativeWorkRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCreativeWork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation creativeWorkAsync
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->creativeWorkAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creativeWorkAsyncWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWork';
        $request = $this->creativeWorkRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creativeWork'
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creativeWorkRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creativeWork'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling creativeWork'
            );
        }

        $resourcePath = '/creativeWorks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation currentTermVersion
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function currentTermVersion($term_code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->currentTermVersionWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation currentTermVersionWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function currentTermVersionWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation currentTermVersionAsync
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsync($term_code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        return $this->currentTermVersionAsyncWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation currentTermVersionAsyncWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsyncWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'currentTermVersion'
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function currentTermVersionRequest($term_code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'term_code' is set
        if ($term_code === null || (is_array($term_code) && count($term_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term_code when calling currentTermVersion'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling currentTermVersion'
            );
        }

        $resourcePath = '/termversions/{termCode}/currentVersion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($term_code !== null) {
            $resourcePath = str_replace(
                '{' . 'termCode' . '}',
                ObjectSerializer::toPathValue($term_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation event
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEvent
     */
    public function event($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->eventWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation eventWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventAsync
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->eventAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventAsyncWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'event'
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling event'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling event'
            );
        }

        $resourcePath = '/events/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventDailyForecast
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function eventDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventDailyForecastWithHttpInfo
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function eventDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->eventDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventDailyForecastAsync
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventDailyForecastAsyncWithHttpInfo
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->eventDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventDailyForecast'
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling eventDailyForecast'
            );
        }

        $resourcePath = '/events/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventHourlyForecast
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function eventHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventHourlyForecastWithHttpInfo
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->eventHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventHourlyForecastAsync
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventHourlyForecastAsyncWithHttpInfo
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->eventHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventHourlyForecast'
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling eventHourlyForecast'
            );
        }

        $resourcePath = '/events/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventWeather
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function eventWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventWeatherWithHttpInfo
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->eventWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventWeatherAsync
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventWeatherAsyncWithHttpInfo
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->eventWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventWeather'
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling eventWeather'
            );
        }

        $resourcePath = '/events/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishment
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishment
     */
    public function foodEstablishment($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->foodEstablishmentWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation foodEstablishmentWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishment, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentAsync
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->foodEstablishmentAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentAsyncWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishment'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishment'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling foodEstablishment'
            );
        }

        $resourcePath = '/foodEstablishments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeather
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function foodEstablishmentWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherWithHttpInfo
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->foodEstablishmentWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherAsync
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherAsyncWithHttpInfo
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->foodEstablishmentWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeather'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling foodEstablishmentWeather'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecast
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function foodEstablishmentWeatherDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastWithHttpInfo
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->foodEstablishmentWeatherDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastAsync
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->foodEstablishmentWeatherDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeatherDailyForecast'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeatherDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling foodEstablishmentWeatherDailyForecast'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecast
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function foodEstablishmentWeatherHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastWithHttpInfo
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->foodEstablishmentWeatherHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastAsync
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->foodEstablishmentWeatherHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeatherHourlyForecast'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeatherHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling foodEstablishmentWeatherHourlyForecast'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatus
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusGet200TextPlainResponse
     */
    public function getStatus($ocp_apim_subscription_key)
    {
        list($response) = $this->getStatusWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation getStatusWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusGet200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAsync
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsync($ocp_apim_subscription_key)
    {
        return $this->getStatusAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAsyncWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsyncWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatus'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusRequest($ocp_apim_subscription_key)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling getStatus'
            );
        }

        $resourcePath = '/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusAbout
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusResponse
     */
    public function getStatusAbout($ocp_apim_subscription_key)
    {
        list($response) = $this->getStatusAboutWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation getStatusAboutWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusAboutWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAboutAsync
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsync($ocp_apim_subscription_key)
    {
        return $this->getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAboutAsyncWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusAbout'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusAboutRequest($ocp_apim_subscription_key)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling getStatusAbout'
            );
        }

        $resourcePath = '/status/about';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTheCurrentTermVersionsOfThePartner
     *
     * Get the current TermVersions of the partner
     *
     * @param  string $partner_acronym Use partner acronym to set the partner which should be used in the request. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $scope The scope of the term definition (&#x27;profile&#x27; or null) (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersionArray
     */
    public function getTheCurrentTermVersionsOfThePartner($partner_acronym, $ocp_apim_subscription_key, $scope = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->getTheCurrentTermVersionsOfThePartnerWithHttpInfo($partner_acronym, $ocp_apim_subscription_key, $scope, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation getTheCurrentTermVersionsOfThePartnerWithHttpInfo
     *
     * Get the current TermVersions of the partner
     *
     * @param  string $partner_acronym Use partner acronym to set the partner which should be used in the request. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $scope The scope of the term definition (&#x27;profile&#x27; or null) (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersionArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTheCurrentTermVersionsOfThePartnerWithHttpInfo($partner_acronym, $ocp_apim_subscription_key, $scope = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersionArray';
        $request = $this->getTheCurrentTermVersionsOfThePartnerRequest($partner_acronym, $ocp_apim_subscription_key, $scope, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersionArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTheCurrentTermVersionsOfThePartnerAsync
     *
     * Get the current TermVersions of the partner
     *
     * @param  string $partner_acronym Use partner acronym to set the partner which should be used in the request. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $scope The scope of the term definition (&#x27;profile&#x27; or null) (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTheCurrentTermVersionsOfThePartnerAsync($partner_acronym, $ocp_apim_subscription_key, $scope = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->getTheCurrentTermVersionsOfThePartnerAsyncWithHttpInfo($partner_acronym, $ocp_apim_subscription_key, $scope, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTheCurrentTermVersionsOfThePartnerAsyncWithHttpInfo
     *
     * Get the current TermVersions of the partner
     *
     * @param  string $partner_acronym Use partner acronym to set the partner which should be used in the request. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $scope The scope of the term definition (&#x27;profile&#x27; or null) (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTheCurrentTermVersionsOfThePartnerAsyncWithHttpInfo($partner_acronym, $ocp_apim_subscription_key, $scope = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersionArray';
        $request = $this->getTheCurrentTermVersionsOfThePartnerRequest($partner_acronym, $ocp_apim_subscription_key, $scope, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTheCurrentTermVersionsOfThePartner'
     *
     * @param  string $partner_acronym Use partner acronym to set the partner which should be used in the request. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $scope The scope of the term definition (&#x27;profile&#x27; or null) (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTheCurrentTermVersionsOfThePartnerRequest($partner_acronym, $ocp_apim_subscription_key, $scope = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'partner_acronym' is set
        if ($partner_acronym === null || (is_array($partner_acronym) && count($partner_acronym) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $partner_acronym when calling getTheCurrentTermVersionsOfThePartner'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling getTheCurrentTermVersionsOfThePartner'
            );
        }

        $resourcePath = '/partners/{partnerAcronym}/terms/currentVersion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($partner_acronym !== null) {
            $resourcePath = str_replace(
                '{' . 'partnerAcronym' . '}',
                ObjectSerializer::toPathValue($partner_acronym),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageObject
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObject
     */
    public function imageObject($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->imageObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation imageObjectWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageObjectAsync
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->imageObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageObjectAsyncWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageObject'
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageObjectRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling imageObject'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling imageObject'
            );
        }

        $resourcePath = '/imageObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAdministrativeAreaRegion
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreasResponse
     */
    public function listAdministrativeAreaRegion($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $identifiers = null, $accept_timezone = null, $category_version = null, $accept_language = null)
    {
        list($response) = $this->listAdministrativeAreaRegionWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $identifiers, $accept_timezone, $category_version, $accept_language);
        return $response;
    }

    /**
     * Operation listAdministrativeAreaRegionWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAdministrativeAreaRegionWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $identifiers = null, $accept_timezone = null, $category_version = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $identifiers, $accept_timezone, $category_version, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAdministrativeAreaRegionAsync
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $identifiers = null, $accept_timezone = null, $category_version = null, $accept_language = null)
    {
        return $this->listAdministrativeAreaRegionAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $identifiers, $accept_timezone, $category_version, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $identifiers = null, $accept_timezone = null, $category_version = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $identifiers, $accept_timezone, $category_version, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAdministrativeAreaRegion'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAdministrativeAreaRegionRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $identifiers = null, $accept_timezone = null, $category_version = null, $accept_language = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listAdministrativeAreaRegion'
            );
        }

        $resourcePath = '/areas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAudioObject
     *
     * List AudioObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAudioObjectsResponse
     */
    public function listAudioObject($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listAudioObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listAudioObjectWithHttpInfo
     *
     * List AudioObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAudioObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAudioObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAudioObjectsResponse';
        $request = $this->listAudioObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAudioObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAudioObjectAsync
     *
     * List AudioObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAudioObjectAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listAudioObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAudioObjectAsyncWithHttpInfo
     *
     * List AudioObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAudioObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAudioObjectsResponse';
        $request = $this->listAudioObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAudioObject'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAudioObjectRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listAudioObject'
            );
        }

        $resourcePath = '/audioObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategory
     *
     * List Category
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoriesResponse
     */
    public function listCategory($ocp_apim_subscription_key, $parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $identifiers = null, $accept_language = null, $category_version = null)
    {
        list($response) = $this->listCategoryWithHttpInfo($ocp_apim_subscription_key, $parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $identifiers, $accept_language, $category_version);
        return $response;
    }

    /**
     * Operation listCategoryWithHttpInfo
     *
     * List Category
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoriesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryWithHttpInfo($ocp_apim_subscription_key, $parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $identifiers = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($ocp_apim_subscription_key, $parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $identifiers, $accept_language, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoriesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCategoryAsync
     *
     * List Category
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsync($ocp_apim_subscription_key, $parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $identifiers = null, $accept_language = null, $category_version = null)
    {
        return $this->listCategoryAsyncWithHttpInfo($ocp_apim_subscription_key, $parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $identifiers, $accept_language, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryAsyncWithHttpInfo
     *
     * List Category
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsyncWithHttpInfo($ocp_apim_subscription_key, $parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $identifiers = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($ocp_apim_subscription_key, $parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $identifiers, $accept_language, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategory'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCategoryRequest($ocp_apim_subscription_key, $parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $identifiers = null, $accept_language = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listCategory'
            );
        }

        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_category !== null) {
            $queryParams['parentCategory'] = ObjectSerializer::toQueryValue($parent_category);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCivicStructure
     *
     * List CivicStructure
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructuresResponse
     */
    public function listCivicStructure($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listCivicStructureWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listCivicStructureWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructuresResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCivicStructureWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructuresResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCivicStructureAsync
     *
     * List CivicStructure
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listCivicStructureAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCivicStructureAsyncWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCivicStructure'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCivicStructureRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listCivicStructure'
            );
        }

        $resourcePath = '/civicStructures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCondition
     *
     * List Condition
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsConditionsResponse
     */
    public function listCondition($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        list($response) = $this->listConditionWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);
        return $response;
    }

    /**
     * Operation listConditionWithHttpInfo
     *
     * List Condition
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsConditionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConditionWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsConditionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConditionAsync
     *
     * List Condition
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        return $this->listConditionAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConditionAsyncWithHttpInfo
     *
     * List Condition
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCondition'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConditionRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listCondition'
            );
        }

        $resourcePath = '/conditions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreativeWork
     *
     * List CreativeWork
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCreativeWorksResponse
     */
    public function listCreativeWork($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listCreativeWorkWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listCreativeWorkWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCreativeWorksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreativeWorkWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCreativeWorksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreativeWorkAsync
     *
     * List CreativeWork
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listCreativeWorkAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreativeWorkAsyncWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreativeWork'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCreativeWorkRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listCreativeWork'
            );
        }

        $resourcePath = '/creativeWorks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEvents
     *
     * List Events
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEventsResponse
     */
    public function listEvents($ocp_apim_subscription_key, $updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        list($response) = $this->listEventsWithHttpInfo($ocp_apim_subscription_key, $updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);
        return $response;
    }

    /**
     * Operation listEventsWithHttpInfo
     *
     * List Events
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEventsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEventsWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($ocp_apim_subscription_key, $updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEventsAsync
     *
     * List Events
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsync($ocp_apim_subscription_key, $updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        return $this->listEventsAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEventsAsyncWithHttpInfo
     *
     * List Events
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($ocp_apim_subscription_key, $updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $identifiers, $accept_timezone, $accept_language, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEvents'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listEventsRequest($ocp_apim_subscription_key, $updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_timezone = null, $accept_language = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listEvents'
            );
        }

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFoodEstablishment
     *
     * List FoodEstablishment
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishmentsResponse
     */
    public function listFoodEstablishment($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listFoodEstablishmentWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listFoodEstablishmentWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFoodEstablishmentWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFoodEstablishmentAsync
     *
     * List FoodEstablishment
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listFoodEstablishmentAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFoodEstablishmentAsyncWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFoodEstablishment'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFoodEstablishmentRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listFoodEstablishment'
            );
        }

        $resourcePath = '/foodEstablishments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listImageObject
     *
     * List ImageObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObjectsResponse
     */
    public function listImageObject($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listImageObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listImageObjectWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listImageObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listImageObjectAsync
     *
     * List ImageObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listImageObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listImageObjectAsyncWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listImageObject'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listImageObjectRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listImageObject'
            );
        }

        $resourcePath = '/imageObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLocalBusiness
     *
     * List LocalBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusinessesResponse
     */
    public function listLocalBusiness($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listLocalBusinessWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listLocalBusinessWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLocalBusinessWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLocalBusinessAsync
     *
     * List LocalBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listLocalBusinessAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLocalBusinessAsyncWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLocalBusiness'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLocalBusinessRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listLocalBusiness'
            );
        }

        $resourcePath = '/localbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLodgingBusiness
     *
     * List LodgingBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusinessesResponse
     */
    public function listLodgingBusiness($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listLodgingBusinessWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listLodgingBusinessWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLodgingBusinessWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLodgingBusinessAsync
     *
     * List LodgingBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listLodgingBusinessAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLodgingBusinessAsyncWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLodgingBusiness'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLodgingBusinessRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listLodgingBusiness'
            );
        }

        $resourcePath = '/lodgingbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMediaObject
     *
     * List MediaObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsMediaObjectsResponse
     */
    public function listMediaObject($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listMediaObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listMediaObjectWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsMediaObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMediaObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsMediaObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMediaObjectAsync
     *
     * List MediaObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listMediaObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMediaObjectAsyncWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMediaObject'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMediaObjectRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listMediaObject'
            );
        }

        $resourcePath = '/mediaObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPlace
     *
     * List Place
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlacesResponse
     */
    public function listPlace($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listPlaceWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listPlaceWithHttpInfo
     *
     * List Place
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlacesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPlaceWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlacesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPlaceAsync
     *
     * List Place
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listPlaceAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPlaceAsyncWithHttpInfo
     *
     * List Place
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPlace'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPlaceRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listPlace'
            );
        }

        $resourcePath = '/places';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProducts
     *
     * List Products
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProductsResponse
     */
    public function listProducts($ocp_apim_subscription_key, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $category_version = null)
    {
        list($response) = $this->listProductsWithHttpInfo($ocp_apim_subscription_key, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $category_version);
        return $response;
    }

    /**
     * Operation listProductsWithHttpInfo
     *
     * List Products
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProductsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProductsWithHttpInfo($ocp_apim_subscription_key, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($ocp_apim_subscription_key, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProductsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProductsAsync
     *
     * List Products
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsync($ocp_apim_subscription_key, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $category_version = null)
    {
        return $this->listProductsAsyncWithHttpInfo($ocp_apim_subscription_key, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProductsAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsyncWithHttpInfo($ocp_apim_subscription_key, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($ocp_apim_subscription_key, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $description_mode, $accept_language, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProducts'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProductsRequest($ocp_apim_subscription_key, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $description_mode = null, $accept_language = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listProducts'
            );
        }

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listReview
     *
     * List Review
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsReviewResponse
     */
    public function listReview($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listReviewWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listReviewWithHttpInfo
     *
     * List Review
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsReviewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listReviewWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsReviewResponse';
        $request = $this->listReviewRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsReviewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listReviewAsync
     *
     * List Review
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listReviewAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listReviewAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listReviewAsyncWithHttpInfo
     *
     * List Review
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listReviewAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsReviewResponse';
        $request = $this->listReviewRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listReview'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listReviewRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listReview'
            );
        }

        $resourcePath = '/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSkiResort
     *
     * List SkiResort
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSkiResortsResponse
     */
    public function listSkiResort($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listSkiResortWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listSkiResortWithHttpInfo
     *
     * List SkiResort
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSkiResortsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSkiResortWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSkiResortsResponse';
        $request = $this->listSkiResortRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSkiResortsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSkiResortAsync
     *
     * List SkiResort
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSkiResortAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listSkiResortAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSkiResortAsyncWithHttpInfo
     *
     * List SkiResort
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSkiResortAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSkiResortsResponse';
        $request = $this->listSkiResortRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSkiResort'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSkiResortRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listSkiResort'
            );
        }

        $resourcePath = '/skiresorts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTag
     *
     * List Tag
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $additional_type Filter by the additional type property (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $usage usage (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTagsResponse
     */
    public function listTag($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $additional_type = null, $include_count = null, $usage = null, $identifiers = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTagWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $additional_type, $include_count, $usage, $identifiers, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTagWithHttpInfo
     *
     * List Tag
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $additional_type Filter by the additional type property (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $usage usage (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTagsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTagWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $additional_type = null, $include_count = null, $usage = null, $identifiers = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $additional_type, $include_count, $usage, $identifiers, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTagsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTagAsync
     *
     * List Tag
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $additional_type Filter by the additional type property (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $usage usage (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $additional_type = null, $include_count = null, $usage = null, $identifiers = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTagAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $additional_type, $include_count, $usage, $identifiers, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTagAsyncWithHttpInfo
     *
     * List Tag
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $additional_type Filter by the additional type property (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $usage usage (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $additional_type = null, $include_count = null, $usage = null, $identifiers = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $additional_type, $include_count, $usage, $identifiers, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTag'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $additional_type Filter by the additional type property (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $usage usage (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTagRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $additional_type = null, $include_count = null, $usage = null, $identifiers = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listTag'
            );
        }

        $resourcePath = '/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($additional_type !== null) {
            $queryParams['additionalType'] = ObjectSerializer::toQueryValue($additional_type);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($usage !== null) {
            $queryParams['usage'] = ObjectSerializer::toQueryValue($usage);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTimezones
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTimeZoneResponseArray
     */
    public function listTimezones($ocp_apim_subscription_key)
    {
        list($response) = $this->listTimezonesWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation listTimezonesWithHttpInfo
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTimeZoneResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTimezonesWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTimeZoneResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTimezonesAsync
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsync($ocp_apim_subscription_key)
    {
        return $this->listTimezonesAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTimezonesAsyncWithHttpInfo
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsyncWithHttpInfo($ocp_apim_subscription_key)
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTimezones'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTimezonesRequest($ocp_apim_subscription_key)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listTimezones'
            );
        }

        $resourcePath = '/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTour
     *
     * List Tour
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsToursResponse
     */
    public function listTour($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listTourWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listTourWithHttpInfo
     *
     * List Tour
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsToursResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTourWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsToursResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTourAsync
     *
     * List Tour
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listTourAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTourAsyncWithHttpInfo
     *
     * List Tour
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTour'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTourRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listTour'
            );
        }

        $resourcePath = '/tours';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVideoObject
     *
     * List VideoObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsVideoObjectsResponse
     */
    public function listVideoObject($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listVideoObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listVideoObjectWithHttpInfo
     *
     * List VideoObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsVideoObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVideoObjectWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsVideoObjectsResponse';
        $request = $this->listVideoObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsVideoObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listVideoObjectAsync
     *
     * List VideoObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVideoObjectAsync($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listVideoObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVideoObjectAsyncWithHttpInfo
     *
     * List VideoObject
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listVideoObjectAsyncWithHttpInfo($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsVideoObjectsResponse';
        $request = $this->listVideoObjectRequest($ocp_apim_subscription_key, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVideoObject'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listVideoObjectRequest($ocp_apim_subscription_key, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listVideoObject'
            );
        }

        $resourcePath = '/videoObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebcams
     *
     * List Webcams
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcamsResponse
     */
    public function listWebcams($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->listWebcamsWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation listWebcamsWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcamsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebcamsWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcamsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebcamsAsync
     *
     * List Webcams
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsync($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->listWebcamsAsyncWithHttpInfo($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebcamsAsyncWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsyncWithHttpInfo($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($ocp_apim_subscription_key, $category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $identifiers, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebcams'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $identifiers Identifiers of the objects to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listWebcamsRequest($ocp_apim_subscription_key, $category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $identifiers = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling listWebcams'
            );
        }

        $resourcePath = '/webcams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($identifiers !== null) {
            $queryParams['identifiers'] = ObjectSerializer::toQueryValue($identifiers);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusiness
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusiness
     */
    public function localBusiness($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->localBusinessWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation localBusinessWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessAsync
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->localBusinessAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessAsyncWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusiness'
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusiness'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling localBusiness'
            );
        }

        $resourcePath = '/localbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessDailyForecast
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function localBusinessDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessDailyForecastWithHttpInfo
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->localBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessDailyForecastAsync
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessDailyForecastAsyncWithHttpInfo
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->localBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessDailyForecast'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling localBusinessDailyForecast'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessHourlyForecast
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function localBusinessHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessHourlyForecastWithHttpInfo
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->localBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessHourlyForecastAsync
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessHourlyForecastAsyncWithHttpInfo
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->localBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessHourlyForecast'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling localBusinessHourlyForecast'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessWeather
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function localBusinessWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessWeatherWithHttpInfo
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->localBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessWeatherAsync
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessWeatherAsyncWithHttpInfo
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->localBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessWeather'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling localBusinessWeather'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusiness
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusiness
     */
    public function lodgingBusiness($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->lodgingBusinessWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation lodgingBusinessWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessAsync
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->lodgingBusinessAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessAsyncWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusiness'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusiness'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling lodgingBusiness'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessDailyForecast
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function lodgingBusinessDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessDailyForecastWithHttpInfo
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->lodgingBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessDailyForecastAsync
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessDailyForecastAsyncWithHttpInfo
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->lodgingBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessDailyForecast'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling lodgingBusinessDailyForecast'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessHourlyForecast
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function lodgingBusinessHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessHourlyForecastWithHttpInfo
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->lodgingBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessHourlyForecastAsync
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessHourlyForecastAsyncWithHttpInfo
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->lodgingBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessHourlyForecast'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling lodgingBusinessHourlyForecast'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessWeather
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function lodgingBusinessWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessWeatherWithHttpInfo
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->lodgingBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessWeatherAsync
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessWeatherAsyncWithHttpInfo
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->lodgingBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessWeather'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling lodgingBusinessWeather'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mediaObject
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsMediaObject
     */
    public function mediaObject($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->mediaObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation mediaObjectWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsMediaObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function mediaObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObject';
        $request = $this->mediaObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsMediaObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mediaObjectAsync
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->mediaObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mediaObjectAsyncWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObject';
        $request = $this->mediaObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mediaObject'
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mediaObjectRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling mediaObject'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling mediaObject'
            );
        }

        $resourcePath = '/mediaObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation place
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlace
     */
    public function place($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->placeWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation placeWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlace, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlace',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeAsync
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->placeAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeAsyncWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'place'
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling place'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling place'
            );
        }

        $resourcePath = '/places/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeDailyForecast
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function placeDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeDailyForecastWithHttpInfo
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function placeDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->placeDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeDailyForecastAsync
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeDailyForecastAsyncWithHttpInfo
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->placeDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeDailyForecast'
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling placeDailyForecast'
            );
        }

        $resourcePath = '/places/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeHourlyForecast
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function placeHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeHourlyForecastWithHttpInfo
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->placeHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeHourlyForecastAsync
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeHourlyForecastAsyncWithHttpInfo
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->placeHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeHourlyForecast'
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling placeHourlyForecast'
            );
        }

        $resourcePath = '/places/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeWeather
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function placeWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeWeatherWithHttpInfo
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->placeWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeWeatherAsync
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeWeatherAsyncWithHttpInfo
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->placeWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeWeather'
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling placeWeather'
            );
        }

        $resourcePath = '/places/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation product
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProduct
     */
    public function product($id, $ocp_apim_subscription_key, $project = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->productWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $description_mode, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation productWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $ocp_apim_subscription_key, $project, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAsync
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsync($id, $ocp_apim_subscription_key, $project = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->productAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $description_mode, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAsyncWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $ocp_apim_subscription_key, $project, $select, $description_mode, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'product'
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $description_mode Use property to extract additional information from description to additionalProperty. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productRequest($id, $ocp_apim_subscription_key, $project = null, $select = null, $description_mode = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling product'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling product'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($description_mode !== null) {
            $queryParams['descriptionMode'] = ObjectSerializer::toQueryValue($description_mode);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productByProductVariantId
     *
     * Product by ProductVariantId
     *
     * @param  string $product_variant_id Use property to get product object by product variant identifier. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProduct
     */
    public function productByProductVariantId($product_variant_id, $ocp_apim_subscription_key, $project = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->productByProductVariantIdWithHttpInfo($product_variant_id, $ocp_apim_subscription_key, $project, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation productByProductVariantIdWithHttpInfo
     *
     * Product by ProductVariantId
     *
     * @param  string $product_variant_id Use property to get product object by product variant identifier. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productByProductVariantIdWithHttpInfo($product_variant_id, $ocp_apim_subscription_key, $project = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productByProductVariantIdRequest($product_variant_id, $ocp_apim_subscription_key, $project, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productByProductVariantIdAsync
     *
     * Product by ProductVariantId
     *
     * @param  string $product_variant_id Use property to get product object by product variant identifier. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productByProductVariantIdAsync($product_variant_id, $ocp_apim_subscription_key, $project = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->productByProductVariantIdAsyncWithHttpInfo($product_variant_id, $ocp_apim_subscription_key, $project, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productByProductVariantIdAsyncWithHttpInfo
     *
     * Product by ProductVariantId
     *
     * @param  string $product_variant_id Use property to get product object by product variant identifier. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productByProductVariantIdAsyncWithHttpInfo($product_variant_id, $ocp_apim_subscription_key, $project = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productByProductVariantIdRequest($product_variant_id, $ocp_apim_subscription_key, $project, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productByProductVariantId'
     *
     * @param  string $product_variant_id Use property to get product object by product variant identifier. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productByProductVariantIdRequest($product_variant_id, $ocp_apim_subscription_key, $project = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'product_variant_id' is set
        if ($product_variant_id === null || (is_array($product_variant_id) && count($product_variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_id when calling productByProductVariantId'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling productByProductVariantId'
            );
        }

        $resourcePath = '/productVariants/{productVariantId}/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($product_variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productVariantId' . '}',
                ObjectSerializer::toPathValue($product_variant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation review
     *
     * Review
     *
     * @param  string $id Use property identifier of Review to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsReview
     */
    public function review($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->reviewWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation reviewWithHttpInfo
     *
     * Review
     *
     * @param  string $id Use property identifier of Review to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsReview, HTTP status code, HTTP response headers (array of strings)
     */
    public function reviewWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsReview';
        $request = $this->reviewRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsReview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reviewAsync
     *
     * Review
     *
     * @param  string $id Use property identifier of Review to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->reviewAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reviewAsyncWithHttpInfo
     *
     * Review
     *
     * @param  string $id Use property identifier of Review to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reviewAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsReview';
        $request = $this->reviewRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'review'
     *
     * @param  string $id Use property identifier of Review to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reviewRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling review'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling review'
            );
        }

        $resourcePath = '/reviews/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function search($ocp_apim_subscription_key, $body = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->searchWithHttpInfo($ocp_apim_subscription_key, $body, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($ocp_apim_subscription_key, $body = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($ocp_apim_subscription_key, $body, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($ocp_apim_subscription_key, $body = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->searchAsyncWithHttpInfo($ocp_apim_subscription_key, $body, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($ocp_apim_subscription_key, $body = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($ocp_apim_subscription_key, $body, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($ocp_apim_subscription_key, $body = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling search'
            );
        }

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByGET
     *
     * Search by GET
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $has_review Use property for filtering by &#x60;hasReview&#x60; (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $source_partner Use property for filtering/facet-filtering by &#x60;sourcePartner&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function searchByGET($ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $has_review = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $source_partner = null, $campaign_tag = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->searchByGETWithHttpInfo($ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $has_review, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $source_partner, $campaign_tag, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation searchByGETWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $has_review Use property for filtering by &#x60;hasReview&#x60; (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $source_partner Use property for filtering/facet-filtering by &#x60;sourcePartner&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByGETWithHttpInfo($ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $has_review = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $source_partner = null, $campaign_tag = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $has_review, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $source_partner, $campaign_tag, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByGETAsync
     *
     * Search by GET
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $has_review Use property for filtering by &#x60;hasReview&#x60; (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $source_partner Use property for filtering/facet-filtering by &#x60;sourcePartner&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsync($ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $has_review = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $source_partner = null, $campaign_tag = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->searchByGETAsyncWithHttpInfo($ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $has_review, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $source_partner, $campaign_tag, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByGETAsyncWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $has_review Use property for filtering by &#x60;hasReview&#x60; (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $source_partner Use property for filtering/facet-filtering by &#x60;sourcePartner&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsyncWithHttpInfo($ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $has_review = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $source_partner = null, $campaign_tag = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $has_review, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $source_partner, $campaign_tag, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByGET'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $has_review Use property for filtering by &#x60;hasReview&#x60; (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $source_partner Use property for filtering/facet-filtering by &#x60;sourcePartner&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByGETRequest($ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $has_review = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $source_partner = null, $campaign_tag = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling searchByGET'
            );
        }

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($search_text);
        }
        // query params
        if ($search_fields !== null) {
            $queryParams['searchFields'] = ObjectSerializer::toQueryValue($search_fields);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($current_page !== null) {
            $queryParams['currentPage'] = ObjectSerializer::toQueryValue($current_page);
        }
        // query params
        if ($results_per_page !== null) {
            $queryParams['resultsPerPage'] = ObjectSerializer::toQueryValue($results_per_page);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($filters !== null) {
            $queryParams['filters'] = ObjectSerializer::toQueryValue($filters);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($combined_type !== null) {
            $queryParams['combinedType'] = ObjectSerializer::toQueryValue($combined_type);
        }
        // query params
        if ($combined_type_tree !== null) {
            $queryParams['combinedTypeTree'] = ObjectSerializer::toQueryValue($combined_type_tree);
        }
        // query params
        if ($leaf_type !== null) {
            $queryParams['leafType'] = ObjectSerializer::toQueryValue($leaf_type);
        }
        // query params
        if ($profile_tag !== null) {
            $queryParams['profileTag'] = ObjectSerializer::toQueryValue($profile_tag);
        }
        // query params
        if ($all_tag !== null) {
            $queryParams['allTag'] = ObjectSerializer::toQueryValue($all_tag);
        }
        // query params
        if ($scoring_tag !== null) {
            $queryParams['scoringTag'] = ObjectSerializer::toQueryValue($scoring_tag);
        }
        // query params
        if ($has_review !== null) {
            $queryParams['hasReview'] = ObjectSerializer::toQueryValue($has_review);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($category_tree !== null) {
            $queryParams['categoryTree'] = ObjectSerializer::toQueryValue($category_tree);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($address_locality !== null) {
            $queryParams['addressLocality'] = ObjectSerializer::toQueryValue($address_locality);
        }
        // query params
        if ($address_postal_code !== null) {
            $queryParams['addressPostalCode'] = ObjectSerializer::toQueryValue($address_postal_code);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = ObjectSerializer::toQueryValue($time);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state);
        }
        // query params
        if ($rating_condition !== null) {
            $queryParams['ratingCondition'] = ObjectSerializer::toQueryValue($rating_condition);
        }
        // query params
        if ($rating_difficulty !== null) {
            $queryParams['ratingDifficulty'] = ObjectSerializer::toQueryValue($rating_difficulty);
        }
        // query params
        if ($elevation_ascent !== null) {
            $queryParams['elevationAscent'] = ObjectSerializer::toQueryValue($elevation_ascent);
        }
        // query params
        if ($elevation_descent !== null) {
            $queryParams['elevationDescent'] = ObjectSerializer::toQueryValue($elevation_descent);
        }
        // query params
        if ($elevation_min_altitude !== null) {
            $queryParams['elevationMinAltitude'] = ObjectSerializer::toQueryValue($elevation_min_altitude);
        }
        // query params
        if ($elevation_max_altitude !== null) {
            $queryParams['elevationMaxAltitude'] = ObjectSerializer::toQueryValue($elevation_max_altitude);
        }
        // query params
        if ($season !== null) {
            $queryParams['season'] = ObjectSerializer::toQueryValue($season);
        }
        // query params
        if ($source_partner !== null) {
            $queryParams['sourcePartner'] = ObjectSerializer::toQueryValue($source_partner);
        }
        // query params
        if ($campaign_tag !== null) {
            $queryParams['campaignTag'] = ObjectSerializer::toQueryValue($campaign_tag);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByGETForPdf
     *
     * Search by GET for pdf
     *
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $title Use property for define custom title in the generated pdf (optional)
     * @param  string $leadtext Use property for define custom lead text in the generated pdf (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function searchByGETForPdf($template_project, $template, $ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $campaign_tag = null, $title = null, $leadtext = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchByGETForPdfWithHttpInfo($template_project, $template, $ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $campaign_tag, $title, $leadtext, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchByGETForPdfWithHttpInfo
     *
     * Search by GET for pdf
     *
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $title Use property for define custom title in the generated pdf (optional)
     * @param  string $leadtext Use property for define custom lead text in the generated pdf (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByGETForPdfWithHttpInfo($template_project, $template, $ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $campaign_tag = null, $title = null, $leadtext = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = 'string';
        $request = $this->searchByGETForPdfRequest($template_project, $template, $ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $campaign_tag, $title, $leadtext, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByGETForPdfAsync
     *
     * Search by GET for pdf
     *
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $title Use property for define custom title in the generated pdf (optional)
     * @param  string $leadtext Use property for define custom lead text in the generated pdf (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETForPdfAsync($template_project, $template, $ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $campaign_tag = null, $title = null, $leadtext = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchByGETForPdfAsyncWithHttpInfo($template_project, $template, $ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $campaign_tag, $title, $leadtext, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByGETForPdfAsyncWithHttpInfo
     *
     * Search by GET for pdf
     *
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $title Use property for define custom title in the generated pdf (optional)
     * @param  string $leadtext Use property for define custom lead text in the generated pdf (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETForPdfAsyncWithHttpInfo($template_project, $template, $ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $campaign_tag = null, $title = null, $leadtext = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = 'string';
        $request = $this->searchByGETForPdfRequest($template_project, $template, $ocp_apim_subscription_key, $search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $combined_type_tree, $leaf_type, $profile_tag, $all_tag, $scoring_tag, $location, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $campaign_tag, $title, $leadtext, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByGETForPdf'
     *
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and parentAdditionalType (optional)
     * @param  string $combined_type_tree Use property for filtering by &#x60;combinedTypeTree&#x60; (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $profile_tag Use property for filtering by &#x60;profileTag&#x60; (optional)
     * @param  string $all_tag Use property for filtering by &#x60;allTag&#x60; which contains values from &#x60;tag&#x60;, &#x60;campaignTag&#x60; and &#x60;profileTag&#x60; (optional)
     * @param  string $scoring_tag Use property to score results by profile-tags (optional)
     * @param  string $location Use property for filtering by &#x60;location&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;season&#x60; (optional)
     * @param  string $campaign_tag Use property for filtering/facet-filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $title Use property for define custom title in the generated pdf (optional)
     * @param  string $leadtext Use property for define custom lead text in the generated pdf (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByGETForPdfRequest($template_project, $template, $ocp_apim_subscription_key, $search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $combined_type_tree = null, $leaf_type = null, $profile_tag = null, $all_tag = null, $scoring_tag = null, $location = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $campaign_tag = null, $title = null, $leadtext = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'template_project' is set
        if ($template_project === null || (is_array($template_project) && count($template_project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_project when calling searchByGETForPdf'
            );
        }
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling searchByGETForPdf'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling searchByGETForPdf'
            );
        }

        $resourcePath = '/search/pdf/{templateProject}/{template}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($search_text);
        }
        // query params
        if ($search_fields !== null) {
            $queryParams['searchFields'] = ObjectSerializer::toQueryValue($search_fields);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($current_page !== null) {
            $queryParams['currentPage'] = ObjectSerializer::toQueryValue($current_page);
        }
        // query params
        if ($results_per_page !== null) {
            $queryParams['resultsPerPage'] = ObjectSerializer::toQueryValue($results_per_page);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($filters !== null) {
            $queryParams['filters'] = ObjectSerializer::toQueryValue($filters);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($combined_type !== null) {
            $queryParams['combinedType'] = ObjectSerializer::toQueryValue($combined_type);
        }
        // query params
        if ($combined_type_tree !== null) {
            $queryParams['combinedTypeTree'] = ObjectSerializer::toQueryValue($combined_type_tree);
        }
        // query params
        if ($leaf_type !== null) {
            $queryParams['leafType'] = ObjectSerializer::toQueryValue($leaf_type);
        }
        // query params
        if ($profile_tag !== null) {
            $queryParams['profileTag'] = ObjectSerializer::toQueryValue($profile_tag);
        }
        // query params
        if ($all_tag !== null) {
            $queryParams['allTag'] = ObjectSerializer::toQueryValue($all_tag);
        }
        // query params
        if ($scoring_tag !== null) {
            $queryParams['scoringTag'] = ObjectSerializer::toQueryValue($scoring_tag);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($category_tree !== null) {
            $queryParams['categoryTree'] = ObjectSerializer::toQueryValue($category_tree);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($address_locality !== null) {
            $queryParams['addressLocality'] = ObjectSerializer::toQueryValue($address_locality);
        }
        // query params
        if ($address_postal_code !== null) {
            $queryParams['addressPostalCode'] = ObjectSerializer::toQueryValue($address_postal_code);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = ObjectSerializer::toQueryValue($time);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state);
        }
        // query params
        if ($rating_condition !== null) {
            $queryParams['ratingCondition'] = ObjectSerializer::toQueryValue($rating_condition);
        }
        // query params
        if ($rating_difficulty !== null) {
            $queryParams['ratingDifficulty'] = ObjectSerializer::toQueryValue($rating_difficulty);
        }
        // query params
        if ($elevation_ascent !== null) {
            $queryParams['elevationAscent'] = ObjectSerializer::toQueryValue($elevation_ascent);
        }
        // query params
        if ($elevation_descent !== null) {
            $queryParams['elevationDescent'] = ObjectSerializer::toQueryValue($elevation_descent);
        }
        // query params
        if ($elevation_min_altitude !== null) {
            $queryParams['elevationMinAltitude'] = ObjectSerializer::toQueryValue($elevation_min_altitude);
        }
        // query params
        if ($elevation_max_altitude !== null) {
            $queryParams['elevationMaxAltitude'] = ObjectSerializer::toQueryValue($elevation_max_altitude);
        }
        // query params
        if ($season !== null) {
            $queryParams['season'] = ObjectSerializer::toQueryValue($season);
        }
        // query params
        if ($campaign_tag !== null) {
            $queryParams['campaignTag'] = ObjectSerializer::toQueryValue($campaign_tag);
        }
        // query params
        if ($title !== null) {
            $queryParams['title'] = ObjectSerializer::toQueryValue($title);
        }
        // query params
        if ($leadtext !== null) {
            $queryParams['leadtext'] = ObjectSerializer::toQueryValue($leadtext);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($template_project !== null) {
            $resourcePath = str_replace(
                '{' . 'templateProject' . '}',
                ObjectSerializer::toPathValue($template_project),
                $resourcePath
            );
        }
        // path params
        if ($template !== null) {
            $resourcePath = str_replace(
                '{' . 'template' . '}',
                ObjectSerializer::toPathValue($template),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByPOSTForPdf
     *
     * Search by POST for pdf
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function searchByPOSTForPdf($ocp_apim_subscription_key, $template_project, $template, $body = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchByPOSTForPdfWithHttpInfo($ocp_apim_subscription_key, $template_project, $template, $body, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchByPOSTForPdfWithHttpInfo
     *
     * Search by POST for pdf
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByPOSTForPdfWithHttpInfo($ocp_apim_subscription_key, $template_project, $template, $body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = 'string';
        $request = $this->searchByPOSTForPdfRequest($ocp_apim_subscription_key, $template_project, $template, $body, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByPOSTForPdfAsync
     *
     * Search by POST for pdf
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByPOSTForPdfAsync($ocp_apim_subscription_key, $template_project, $template, $body = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchByPOSTForPdfAsyncWithHttpInfo($ocp_apim_subscription_key, $template_project, $template, $body, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByPOSTForPdfAsyncWithHttpInfo
     *
     * Search by POST for pdf
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByPOSTForPdfAsyncWithHttpInfo($ocp_apim_subscription_key, $template_project, $template, $body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = 'string';
        $request = $this->searchByPOSTForPdfRequest($ocp_apim_subscription_key, $template_project, $template, $body, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByPOSTForPdf'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $template_project Use property to select project which is used to select pdf template (required)
     * @param  string $template Use property to select pdf template in selected project (required)
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByPOSTForPdfRequest($ocp_apim_subscription_key, $template_project, $template, $body = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling searchByPOSTForPdf'
            );
        }
        // verify the required parameter 'template_project' is set
        if ($template_project === null || (is_array($template_project) && count($template_project) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_project when calling searchByPOSTForPdf'
            );
        }
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling searchByPOSTForPdf'
            );
        }

        $resourcePath = '/search/pdf/{templateProject}/{template}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($template_project !== null) {
            $resourcePath = str_replace(
                '{' . 'templateProject' . '}',
                ObjectSerializer::toPathValue($template_project),
                $resourcePath
            );
        }
        // path params
        if ($template !== null) {
            $resourcePath = str_replace(
                '{' . 'template' . '}',
                ObjectSerializer::toPathValue($template),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation skiResort
     *
     * SkiResort
     *
     * @param  string $id Use property identifier of SkiResort to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSkiResort
     */
    public function skiResort($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->skiResortWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation skiResortWithHttpInfo
     *
     * SkiResort
     *
     * @param  string $id Use property identifier of SkiResort to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSkiResort, HTTP status code, HTTP response headers (array of strings)
     */
    public function skiResortWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSkiResort';
        $request = $this->skiResortRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSkiResort',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation skiResortAsync
     *
     * SkiResort
     *
     * @param  string $id Use property identifier of SkiResort to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->skiResortAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation skiResortAsyncWithHttpInfo
     *
     * SkiResort
     *
     * @param  string $id Use property identifier of SkiResort to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSkiResort';
        $request = $this->skiResortRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'skiResort'
     *
     * @param  string $id Use property identifier of SkiResort to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function skiResortRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling skiResort'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling skiResort'
            );
        }

        $resourcePath = '/skiresorts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation skiResortDailyForecast
     *
     * SkiResort daily forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function skiResortDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->skiResortDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation skiResortDailyForecastWithHttpInfo
     *
     * SkiResort daily forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function skiResortDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->skiResortDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation skiResortDailyForecastAsync
     *
     * SkiResort daily forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->skiResortDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation skiResortDailyForecastAsyncWithHttpInfo
     *
     * SkiResort daily forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->skiResortDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'skiResortDailyForecast'
     *
     * @param  string $id Use property identifier of SkiResort to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function skiResortDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling skiResortDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling skiResortDailyForecast'
            );
        }

        $resourcePath = '/skiresorts/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation skiResortHourlyForecast
     *
     * SkiResort hourly forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function skiResortHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->skiResortHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation skiResortHourlyForecastWithHttpInfo
     *
     * SkiResort hourly forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function skiResortHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->skiResortHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation skiResortHourlyForecastAsync
     *
     * SkiResort hourly forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->skiResortHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation skiResortHourlyForecastAsyncWithHttpInfo
     *
     * SkiResort hourly forecast
     *
     * @param  string $id Use property identifier of SkiResort to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->skiResortHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'skiResortHourlyForecast'
     *
     * @param  string $id Use property identifier of SkiResort to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function skiResortHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling skiResortHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling skiResortHourlyForecast'
            );
        }

        $resourcePath = '/skiresorts/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation skiResortWeather
     *
     * SkiResort weather
     *
     * @param  string $id Use property identifier of SkiResort to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function skiResortWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->skiResortWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation skiResortWeatherWithHttpInfo
     *
     * SkiResort weather
     *
     * @param  string $id Use property identifier of SkiResort to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function skiResortWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->skiResortWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation skiResortWeatherAsync
     *
     * SkiResort weather
     *
     * @param  string $id Use property identifier of SkiResort to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->skiResortWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation skiResortWeatherAsyncWithHttpInfo
     *
     * SkiResort weather
     *
     * @param  string $id Use property identifier of SkiResort to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function skiResortWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->skiResortWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'skiResortWeather'
     *
     * @param  string $id Use property identifier of SkiResort to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function skiResortWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling skiResortWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling skiResortWeather'
            );
        }

        $resourcePath = '/skiresorts/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tag
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTag
     */
    public function tag($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tagWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tagWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tagAsync
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsync($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tagAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagAsyncWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $ocp_apim_subscription_key, $project, $select, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tag'
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagRequest($id, $ocp_apim_subscription_key, $project = null, $select = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tag'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling tag'
            );
        }

        $resourcePath = '/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termVersion
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function termVersion($code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->termVersionWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation termVersionWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function termVersionWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation termVersionAsync
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsync($code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        return $this->termVersionAsyncWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termVersionAsyncWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsyncWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termVersion'
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termVersionRequest($code, $ocp_apim_subscription_key, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling termVersion'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling termVersion'
            );
        }

        $resourcePath = '/termversions/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tour
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTour
     */
    public function tour($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->tourWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation tourWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTour, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTour',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourAsync
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->tourAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourAsyncWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tour'
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tour'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling tour'
            );
        }

        $resourcePath = '/tours/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourDailyForecast
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function tourDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourDailyForecastWithHttpInfo
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function tourDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->tourDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourDailyForecastAsync
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourDailyForecastAsyncWithHttpInfo
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->tourDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourDailyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling tourDailyForecast'
            );
        }

        $resourcePath = '/tours/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourHourlyForecast
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function tourHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourHourlyForecastWithHttpInfo
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->tourHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourHourlyForecastAsync
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourHourlyForecastAsyncWithHttpInfo
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->tourHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourHourlyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling tourHourlyForecast'
            );
        }

        $resourcePath = '/tours/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourWeather
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function tourWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourWeatherWithHttpInfo
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->tourWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourWeatherAsync
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourWeatherAsyncWithHttpInfo
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->tourWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourWeather'
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling tourWeather'
            );
        }

        $resourcePath = '/tours/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation treeAdministrativeAreaRegion
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreaTreeItem
     */
    public function treeAdministrativeAreaRegion($id, $ocp_apim_subscription_key, $levels = null, $admin_areas_only = null, $project = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->treeAdministrativeAreaRegionWithHttpInfo($id, $ocp_apim_subscription_key, $levels, $admin_areas_only, $project, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation treeAdministrativeAreaRegionWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreaTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function treeAdministrativeAreaRegionWithHttpInfo($id, $ocp_apim_subscription_key, $levels = null, $admin_areas_only = null, $project = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $levels, $admin_areas_only, $project, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation treeAdministrativeAreaRegionAsync
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsync($id, $ocp_apim_subscription_key, $levels = null, $admin_areas_only = null, $project = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $levels, $admin_areas_only, $project, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation treeAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $levels = null, $admin_areas_only = null, $project = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $levels, $admin_areas_only, $project, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'treeAdministrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true only administrative areas are included. Set to false then all types of areas are included. This kind can destroy the tree structure and combined with high levels the performance can be bad. default &#x3D; false (optional)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function treeAdministrativeAreaRegionRequest($id, $ocp_apim_subscription_key, $levels = null, $admin_areas_only = null, $project = null, $accept_timezone = null, $accept_language = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling treeAdministrativeAreaRegion'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling treeAdministrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($levels !== null) {
            $queryParams['levels'] = ObjectSerializer::toQueryValue($levels);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation typeTree
     *
     * Type Tree
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTypeTree
     */
    public function typeTree($ocp_apim_subscription_key, $accept_language = null)
    {
        list($response) = $this->typeTreeWithHttpInfo($ocp_apim_subscription_key, $accept_language);
        return $response;
    }

    /**
     * Operation typeTreeWithHttpInfo
     *
     * Type Tree
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTypeTree, HTTP status code, HTTP response headers (array of strings)
     */
    public function typeTreeWithHttpInfo($ocp_apim_subscription_key, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTypeTree';
        $request = $this->typeTreeRequest($ocp_apim_subscription_key, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTypeTree',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation typeTreeAsync
     *
     * Type Tree
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function typeTreeAsync($ocp_apim_subscription_key, $accept_language = null)
    {
        return $this->typeTreeAsyncWithHttpInfo($ocp_apim_subscription_key, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation typeTreeAsyncWithHttpInfo
     *
     * Type Tree
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function typeTreeAsyncWithHttpInfo($ocp_apim_subscription_key, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTypeTree';
        $request = $this->typeTreeRequest($ocp_apim_subscription_key, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'typeTree'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function typeTreeRequest($ocp_apim_subscription_key, $accept_language = null)
    {
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling typeTree'
            );
        }

        $resourcePath = '/types/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation videoObject
     *
     * VideoObject
     *
     * @param  string $id Use property identifier of VideoObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsVideoObject
     */
    public function videoObject($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->videoObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation videoObjectWithHttpInfo
     *
     * VideoObject
     *
     * @param  string $id Use property identifier of VideoObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsVideoObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function videoObjectWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsVideoObject';
        $request = $this->videoObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsVideoObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation videoObjectAsync
     *
     * VideoObject
     *
     * @param  string $id Use property identifier of VideoObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoObjectAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->videoObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation videoObjectAsyncWithHttpInfo
     *
     * VideoObject
     *
     * @param  string $id Use property identifier of VideoObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function videoObjectAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsVideoObject';
        $request = $this->videoObjectRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'videoObject'
     *
     * @param  string $id Use property identifier of VideoObject to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function videoObjectRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling videoObject'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling videoObject'
            );
        }

        $resourcePath = '/videoObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcam
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcam
     */
    public function webcam($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        list($response) = $this->webcamWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);
        return $response;
    }

    /**
     * Operation webcamWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcam, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcam',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamAsync
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        return $this->webcamAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamAsyncWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $select, $accept_language, $accept_timezone, $category_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcam'
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $category_version Use to filter categories by version (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $select = null, $accept_language = null, $accept_timezone = null, $category_version = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcam'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling webcam'
            );
        }

        $resourcePath = '/webcams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($category_version !== null) {
            $headerParams['categoryVersion'] = ObjectSerializer::toHeaderValue($category_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamDailyForecast
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecast[]
     */
    public function webcamDailyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamDailyForecastWithHttpInfo
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecast[], HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamDailyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->webcamDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecast[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamDailyForecastAsync
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamDailyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamDailyForecastAsyncWithHttpInfo
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamDailyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecast[]';
        $request = $this->webcamDailyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamDailyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamDailyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamDailyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling webcamDailyForecast'
            );
        }

        $resourcePath = '/webcams/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamHourlyForecast
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function webcamHourlyForecast($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamHourlyForecastWithHttpInfo
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamHourlyForecastWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->webcamHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamHourlyForecastAsync
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamHourlyForecastAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamHourlyForecastAsyncWithHttpInfo
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamHourlyForecastAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->webcamHourlyForecastRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamHourlyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamHourlyForecastRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamHourlyForecast'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling webcamHourlyForecast'
            );
        }

        $resourcePath = '/webcams/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamWeather
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function webcamWeather($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamWeatherWithHttpInfo
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWeatherWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->webcamWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamWeatherAsync
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamWeatherAsync($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamWeatherAsyncWithHttpInfo
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamWeatherAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->webcamWeatherRequest($id, $ocp_apim_subscription_key, $project, $contained_in_place, $duration, $details, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamWeather'
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (required)
     * @param  string $project Required - Use this property to filter objects by a specific project. All partners must provide their project code in this parameter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamWeatherRequest($id, $ocp_apim_subscription_key, $project = null, $contained_in_place = null, $duration = null, $details = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamWeather'
            );
        }
        // verify the required parameter 'ocp_apim_subscription_key' is set
        if ($ocp_apim_subscription_key === null || (is_array($ocp_apim_subscription_key) && count($ocp_apim_subscription_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocp_apim_subscription_key when calling webcamWeather'
            );
        }

        $resourcePath = '/webcams/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
