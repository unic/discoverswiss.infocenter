<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Infocenter-TEST
 *
 * Infocenter-TEST
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.20
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Infocenter\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Infocenter\Client\ApiException;
use Infocenter\Client\Configuration;
use Infocenter\Client\HeaderSelector;
use Infocenter\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation administrativeAreaRegion
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeArea
     */
    public function administrativeAreaRegion($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeArea, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeArea',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionAsync
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionAsyncWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation category
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategory
     */
    public function category($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryAsync
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryAsyncWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'category'
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling category'
            );
        }

        $resourcePath = '/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoryTree
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoryTreeItem
     */
    public function categoryTree($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryTreeWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryTreeWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoryTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryTreeWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoryTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryTreeAsync
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryTreeAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryTreeAsyncWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryTree'
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryTreeRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling categoryTree'
            );
        }

        $resourcePath = '/categories/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructure
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructure
     */
    public function civicStructure($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructure, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureAsync
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureAsyncWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructure'
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructure'
            );
        }

        $resourcePath = '/civicStructures/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation condition
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCondition
     */
    public function condition($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCondition, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCondition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionAsync
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionAsyncWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'condition'
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling condition'
            );
        }

        $resourcePath = '/conditions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creativeWork
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCreativeWork
     */
    public function creativeWork($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->creativeWorkWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation creativeWorkWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCreativeWork, HTTP status code, HTTP response headers (array of strings)
     */
    public function creativeWorkWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWork';
        $request = $this->creativeWorkRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCreativeWork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation creativeWorkAsync
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->creativeWorkAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creativeWorkAsyncWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWork';
        $request = $this->creativeWorkRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creativeWork'
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creativeWorkRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creativeWork'
            );
        }

        $resourcePath = '/creativeWorks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation currentTermVersion
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function currentTermVersion($term_code, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->currentTermVersionWithHttpInfo($term_code, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation currentTermVersionWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function currentTermVersionWithHttpInfo($term_code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation currentTermVersionAsync
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsync($term_code, $accept_language = null, $accept_timezone = null)
    {
        return $this->currentTermVersionAsyncWithHttpInfo($term_code, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation currentTermVersionAsyncWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsyncWithHttpInfo($term_code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'currentTermVersion'
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function currentTermVersionRequest($term_code, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'term_code' is set
        if ($term_code === null || (is_array($term_code) && count($term_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term_code when calling currentTermVersion'
            );
        }

        $resourcePath = '/termversions/{termCode}/currentVersion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($term_code !== null) {
            $resourcePath = str_replace(
                '{' . 'termCode' . '}',
                ObjectSerializer::toPathValue($term_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation event
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEvent
     */
    public function event($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventAsync
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventAsyncWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'event'
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling event'
            );
        }

        $resourcePath = '/events/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishment
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishment
     */
    public function foodEstablishment($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishment, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentAsync
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentAsyncWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishment'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishment'
            );
        }

        $resourcePath = '/foodEstablishments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatus
     *
     * GetStatus
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusGet200TextPlainResponse
     */
    public function getStatus()
    {
        list($response) = $this->getStatusWithHttpInfo();
        return $response;
    }

    /**
     * Operation getStatusWithHttpInfo
     *
     * GetStatus
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusGet200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAsync
     *
     * GetStatus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsync()
    {
        return $this->getStatusAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAsyncWithHttpInfo
     *
     * GetStatus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsyncWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatus'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusRequest()
    {

        $resourcePath = '/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusAbout
     *
     * GetStatusAbout
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusResponse
     */
    public function getStatusAbout()
    {
        list($response) = $this->getStatusAboutWithHttpInfo();
        return $response;
    }

    /**
     * Operation getStatusAboutWithHttpInfo
     *
     * GetStatusAbout
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusAboutWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAboutAsync
     *
     * GetStatusAbout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsync()
    {
        return $this->getStatusAboutAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAboutAsyncWithHttpInfo
     *
     * GetStatusAbout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsyncWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusAbout'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusAboutRequest()
    {

        $resourcePath = '/status/about';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageObject
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObject
     */
    public function imageObject($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->imageObjectWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation imageObjectWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageObjectWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageObjectAsync
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->imageObjectAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageObjectAsyncWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageObject'
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageObjectRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling imageObject'
            );
        }

        $resourcePath = '/imageObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAdministrativeAreaRegion
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreasResponse
     */
    public function listAdministrativeAreaRegion($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listAdministrativeAreaRegionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listAdministrativeAreaRegionWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAdministrativeAreaRegionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAdministrativeAreaRegionAsync
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listAdministrativeAreaRegionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAdministrativeAreaRegion'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAdministrativeAreaRegionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/areas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategory
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoriesResponse
     */
    public function listCategory($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        list($response) = $this->listCategoryWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);
        return $response;
    }

    /**
     * Operation listCategoryWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoriesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoriesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCategoryAsync
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsync($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        return $this->listCategoryAsyncWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryAsyncWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsyncWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategory'
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCategoryRequest($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {

        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_category !== null) {
            $queryParams['parentCategory'] = ObjectSerializer::toQueryValue($parent_category);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCivicStructure
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructuresResponse
     */
    public function listCivicStructure($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCivicStructureWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCivicStructureWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructuresResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCivicStructureWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructuresResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCivicStructureAsync
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCivicStructureAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCivicStructureAsyncWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCivicStructure'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCivicStructureRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/civicStructures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCondition
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsConditionsResponse
     */
    public function listCondition($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listConditionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listConditionWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsConditionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConditionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsConditionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConditionAsync
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listConditionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConditionAsyncWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCondition'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConditionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/conditions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreativeWork
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCreativeWorksResponse
     */
    public function listCreativeWork($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCreativeWorkWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCreativeWorkWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCreativeWorksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreativeWorkWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCreativeWorksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreativeWorkAsync
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCreativeWorkAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreativeWorkAsyncWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreativeWork'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCreativeWorkRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/creativeWorks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEvents
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEventsResponse
     */
    public function listEvents($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listEventsWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listEventsWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEventsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEventsWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEventsAsync
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsync($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listEventsAsyncWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEventsAsyncWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsyncWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEvents'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listEventsRequest($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFoodEstablishment
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishmentsResponse
     */
    public function listFoodEstablishment($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listFoodEstablishmentWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listFoodEstablishmentWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFoodEstablishmentWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFoodEstablishmentAsync
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listFoodEstablishmentAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFoodEstablishmentAsyncWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFoodEstablishment'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFoodEstablishmentRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/foodEstablishments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listImageObject
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObjectsResponse
     */
    public function listImageObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listImageObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listImageObjectWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listImageObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listImageObjectAsync
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listImageObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listImageObjectAsyncWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listImageObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listImageObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/imageObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLocalBusiness
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusinessesResponse
     */
    public function listLocalBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLocalBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLocalBusinessWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLocalBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLocalBusinessAsync
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLocalBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLocalBusinessAsyncWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLocalBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLocalBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/localbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLodgingBusiness
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusinessesResponse
     */
    public function listLodgingBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLodgingBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLodgingBusinessWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLodgingBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLodgingBusinessAsync
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLodgingBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLodgingBusinessAsyncWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLodgingBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLodgingBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/lodgingbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMediaObject
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsMediaObjectsResponse
     */
    public function listMediaObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listMediaObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listMediaObjectWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsMediaObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMediaObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsMediaObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMediaObjectAsync
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listMediaObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMediaObjectAsyncWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMediaObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMediaObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/mediaObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPlace
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlacesResponse
     */
    public function listPlace($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listPlaceWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listPlaceWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlacesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPlaceWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlacesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPlaceAsync
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listPlaceAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPlaceAsyncWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPlace'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPlaceRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/places';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProducts
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProductsResponse
     */
    public function listProducts($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        list($response) = $this->listProductsWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);
        return $response;
    }

    /**
     * Operation listProductsWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProductsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProductsWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProductsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProductsAsync
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsync($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        return $this->listProductsAsyncWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProductsAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsyncWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProducts'
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProductsRequest($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTag
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTagsResponse
     */
    public function listTag($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTagWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTagWithHttpInfo
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTagsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTagWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTagsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTagAsync
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTagAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTagAsyncWithHttpInfo
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTag'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTagRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTimezones
     *
     * List Timezones
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTimeZoneResponseArray
     */
    public function listTimezones()
    {
        list($response) = $this->listTimezonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listTimezonesWithHttpInfo
     *
     * List Timezones
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTimeZoneResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTimezonesWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTimeZoneResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTimezonesAsync
     *
     * List Timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsync()
    {
        return $this->listTimezonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTimezonesAsyncWithHttpInfo
     *
     * List Timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsyncWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTimezones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTimezonesRequest()
    {

        $resourcePath = '/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTour
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsToursResponse
     */
    public function listTour($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTourWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTourWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsToursResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTourWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsToursResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTourAsync
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTourAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTourAsyncWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTour'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTourRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/tours';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebcams
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcamsResponse
     */
    public function listWebcams($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listWebcamsWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listWebcamsWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcamsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebcamsWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcamsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebcamsAsync
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listWebcamsAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebcamsAsyncWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebcams'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listWebcamsRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/webcams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusiness
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusiness
     */
    public function localBusiness($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessAsync
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessAsyncWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusiness'
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusiness'
            );
        }

        $resourcePath = '/localbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusiness
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusiness
     */
    public function lodgingBusiness($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessAsync
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessAsyncWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusiness'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusiness'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mediaObject
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsMediaObject
     */
    public function mediaObject($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->mediaObjectWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation mediaObjectWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsMediaObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function mediaObjectWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObject';
        $request = $this->mediaObjectRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsMediaObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mediaObjectAsync
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->mediaObjectAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mediaObjectAsyncWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObject';
        $request = $this->mediaObjectRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mediaObject'
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mediaObjectRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling mediaObject'
            );
        }

        $resourcePath = '/mediaObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation place
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlace
     */
    public function place($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlace, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlace',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeAsync
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeAsyncWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'place'
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling place'
            );
        }

        $resourcePath = '/places/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation product
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProduct
     */
    public function product($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->productWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation productWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAsync
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->productAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAsyncWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'product'
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling product'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsExtendedSearchRequest $body body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function search($body = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchWithHttpInfo($body, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($body, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($body = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchAsyncWithHttpInfo($body, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($body, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  \Infocenter\Client\Model\DsExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($body = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByGET
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function searchByGET($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchByGETWithHttpInfo($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchByGETWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByGETWithHttpInfo($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByGETAsync
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsync($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchByGETAsyncWithHttpInfo($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByGETAsyncWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsyncWithHttpInfo($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByGET'
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByGETRequest($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($search_text);
        }
        // query params
        if ($current_page !== null) {
            $queryParams['currentPage'] = ObjectSerializer::toQueryValue($current_page);
        }
        // query params
        if ($results_per_page !== null) {
            $queryParams['resultsPerPage'] = ObjectSerializer::toQueryValue($results_per_page);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($filters !== null) {
            $queryParams['filters'] = ObjectSerializer::toQueryValue($filters);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tag
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTag
     */
    public function tag($id, $project = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tagWithHttpInfo($id, $project, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tagWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagWithHttpInfo($id, $project = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $project, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tagAsync
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsync($id, $project = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tagAsyncWithHttpInfo($id, $project, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagAsyncWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsyncWithHttpInfo($id, $project = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $project, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tag'
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagRequest($id, $project = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tag'
            );
        }

        $resourcePath = '/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termVersion
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function termVersion($code, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->termVersionWithHttpInfo($code, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation termVersionWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function termVersionWithHttpInfo($code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation termVersionAsync
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsync($code, $accept_language = null, $accept_timezone = null)
    {
        return $this->termVersionAsyncWithHttpInfo($code, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termVersionAsyncWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsyncWithHttpInfo($code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termVersion'
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termVersionRequest($code, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling termVersion'
            );
        }

        $resourcePath = '/termversions/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tour
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTour
     */
    public function tour($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTour, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTour',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourAsync
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourAsyncWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tour'
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tour'
            );
        }

        $resourcePath = '/tours/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation treeAdministrativeAreaRegion
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreaTreeItem
     */
    public function treeAdministrativeAreaRegion($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->treeAdministrativeAreaRegionWithHttpInfo($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation treeAdministrativeAreaRegionWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreaTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function treeAdministrativeAreaRegionWithHttpInfo($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation treeAdministrativeAreaRegionAsync
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsync($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels, $admin_areas_only, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation treeAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'treeAdministrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function treeAdministrativeAreaRegionRequest($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling treeAdministrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($levels !== null) {
            $queryParams['levels'] = ObjectSerializer::toQueryValue($levels);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcam
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcam
     */
    public function webcam($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcam, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcam',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamAsync
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsync($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamAsyncWithHttpInfo($id, $project, $contained_in_place, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamAsyncWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $project, $contained_in_place, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcam'
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamRequest($id, $project = null, $contained_in_place = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcam'
            );
        }

        $resourcePath = '/webcams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
