<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Infocenter-TEST-V2
 *
 * Infocenter API test-v2
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.20
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Infocenter\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Infocenter\Client\ApiException;
use Infocenter\Client\Configuration;
use Infocenter\Client\HeaderSelector;
use Infocenter\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation administrativeAreaRegion
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeArea
     */
    public function administrativeAreaRegion($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeArea, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeArea',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionAsync
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionAsyncWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionDailyForecast
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function administrativeAreaRegionDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionDailyForecastWithHttpInfo
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->administrativeAreaRegionDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionDailyForecastAsync
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionDailyForecastAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) daily forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->administrativeAreaRegionDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionDailyForecast'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionDailyForecast'
            );
        }

        $resourcePath = '/areas/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionHourlyForecast
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function administrativeAreaRegionHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastWithHttpInfo
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->administrativeAreaRegionHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastAsync
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionHourlyForecastAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) hourly forecast
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->administrativeAreaRegionHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionHourlyForecast'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionHourlyForecast'
            );
        }

        $resourcePath = '/areas/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation administrativeAreaRegionWeather
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function administrativeAreaRegionWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWeatherWithHttpInfo
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->administrativeAreaRegionWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionWeatherAsync
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionWeatherAsyncWithHttpInfo
     *
     * AdministrativeArea (Region) weather
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->administrativeAreaRegionWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegionWeather'
     *
     * @param  string $id Use property identifier of AdministrativeArea to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegionWeather'
            );
        }

        $resourcePath = '/areas/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation category
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategory
     */
    public function category($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryAsync
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryAsyncWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategory';
        $request = $this->categoryRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'category'
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling category'
            );
        }

        $resourcePath = '/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoryTree
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoryTreeItem
     */
    public function categoryTree($id, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryTreeWithHttpInfo($id, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryTreeWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoryTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryTreeWithHttpInfo($id, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoryTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryTreeAsync
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsync($id, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryTreeAsyncWithHttpInfo($id, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryTreeAsyncWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsyncWithHttpInfo($id, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryTree'
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryTreeRequest($id, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling categoryTree'
            );
        }

        $resourcePath = '/categories/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructure
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructure
     */
    public function civicStructure($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructure, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureAsync
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureAsyncWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructure';
        $request = $this->civicStructureRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructure'
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructure'
            );
        }

        $resourcePath = '/civicStructures/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureDailyForecast
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function civicStructureDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureDailyForecastWithHttpInfo
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->civicStructureDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureDailyForecastAsync
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureDailyForecastAsyncWithHttpInfo
     *
     * CivicStructure daily forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->civicStructureDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureDailyForecast'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureDailyForecast'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureHourlyForecast
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function civicStructureHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureHourlyForecastWithHttpInfo
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->civicStructureHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureHourlyForecastAsync
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureHourlyForecastAsyncWithHttpInfo
     *
     * CivicStructure hourly forecast
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->civicStructureHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureHourlyForecast'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureHourlyForecast'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructureWeather
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function civicStructureWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureWeatherWithHttpInfo
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->civicStructureWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureWeatherAsync
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureWeatherAsyncWithHttpInfo
     *
     * CivicStructure weather
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->civicStructureWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructureWeather'
     *
     * @param  string $id Use property identifier of CivicStructure to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructureWeather'
            );
        }

        $resourcePath = '/civicStructures/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation condition
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCondition
     */
    public function condition($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCondition, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCondition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionAsync
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionAsyncWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCondition';
        $request = $this->conditionRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'condition'
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling condition'
            );
        }

        $resourcePath = '/conditions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionDailyForecast
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function conditionDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionDailyForecastWithHttpInfo
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->conditionDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionDailyForecastAsync
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionDailyForecastAsyncWithHttpInfo
     *
     * Condition daily forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->conditionDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionDailyForecast'
     *
     * @param  string $id Use property identifier of Condition to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionDailyForecast'
            );
        }

        $resourcePath = '/conditions/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionHourlyForecast
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function conditionHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionHourlyForecastWithHttpInfo
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->conditionHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionHourlyForecastAsync
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionHourlyForecastAsyncWithHttpInfo
     *
     * Condition hourly forecast
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->conditionHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionHourlyForecast'
     *
     * @param  string $id Use property identifier of Condition to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionHourlyForecast'
            );
        }

        $resourcePath = '/conditions/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation conditionWeather
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function conditionWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionWeatherWithHttpInfo
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->conditionWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionWeatherAsync
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionWeatherAsyncWithHttpInfo
     *
     * Condition weather
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->conditionWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'conditionWeather'
     *
     * @param  string $id Use property identifier of Condition to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling conditionWeather'
            );
        }

        $resourcePath = '/conditions/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creativeWork
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function creativeWork($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->creativeWorkWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation creativeWorkWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function creativeWorkWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->creativeWorkRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation creativeWorkAsync
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->creativeWorkAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creativeWorkAsyncWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->creativeWorkRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creativeWork'
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creativeWorkRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creativeWork'
            );
        }

        $resourcePath = '/creativeWorks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation currentTermVersion
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function currentTermVersion($term_code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->currentTermVersionWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation currentTermVersionWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function currentTermVersionWithHttpInfo($term_code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation currentTermVersionAsync
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsync($term_code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->currentTermVersionAsyncWithHttpInfo($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation currentTermVersionAsyncWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsyncWithHttpInfo($term_code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->currentTermVersionRequest($term_code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'currentTermVersion'
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function currentTermVersionRequest($term_code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'term_code' is set
        if ($term_code === null || (is_array($term_code) && count($term_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term_code when calling currentTermVersion'
            );
        }

        $resourcePath = '/termversions/{termCode}/currentVersion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($term_code !== null) {
            $resourcePath = str_replace(
                '{' . 'termCode' . '}',
                ObjectSerializer::toPathValue($term_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation event
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEvent
     */
    public function event($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventAsync
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventAsyncWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEvent';
        $request = $this->eventRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'event'
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling event'
            );
        }

        $resourcePath = '/events/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventDailyForecast
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function eventDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventDailyForecastWithHttpInfo
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->eventDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventDailyForecastAsync
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventDailyForecastAsyncWithHttpInfo
     *
     * Event daily forecast
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->eventDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventDailyForecast'
     *
     * @param  string $id Use property identifier of Event to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventDailyForecast'
            );
        }

        $resourcePath = '/events/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventHourlyForecast
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function eventHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventHourlyForecastWithHttpInfo
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->eventHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventHourlyForecastAsync
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventHourlyForecastAsyncWithHttpInfo
     *
     * Event hourly forecast
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->eventHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventHourlyForecast'
     *
     * @param  string $id Use property identifier of Event to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventHourlyForecast'
            );
        }

        $resourcePath = '/events/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventWeather
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function eventWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventWeatherWithHttpInfo
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->eventWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventWeatherAsync
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventWeatherAsyncWithHttpInfo
     *
     * Event weather
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->eventWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventWeather'
     *
     * @param  string $id Use property identifier of Event to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventWeather'
            );
        }

        $resourcePath = '/events/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishment
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishment
     */
    public function foodEstablishment($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishment, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentAsync
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentAsyncWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishment'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishment'
            );
        }

        $resourcePath = '/foodEstablishments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeather
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function foodEstablishmentWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherWithHttpInfo
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->foodEstablishmentWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherAsync
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherAsyncWithHttpInfo
     *
     * FoodEstablishment weather
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->foodEstablishmentWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeather'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeather'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecast
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function foodEstablishmentWeatherDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastWithHttpInfo
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->foodEstablishmentWeatherDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastAsync
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo
     *
     * FoodEstablishment weather daily forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->foodEstablishmentWeatherDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeatherDailyForecast'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeatherDailyForecast'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecast
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function foodEstablishmentWeatherHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWeatherHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastWithHttpInfo
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWeatherHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->foodEstablishmentWeatherHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastAsync
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo
     *
     * FoodEstablishment weather hourly forecast
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentWeatherHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->foodEstablishmentWeatherHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishmentWeatherHourlyForecast'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentWeatherHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishmentWeatherHourlyForecast'
            );
        }

        $resourcePath = '/foodEstablishments/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatus
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusGet200TextPlainResponse
     */
    public function getStatus($ocp_apim_subscription_key = null)
    {
        list($response) = $this->getStatusWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation getStatusWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusGet200TextPlainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAsync
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsync($ocp_apim_subscription_key = null)
    {
        return $this->getStatusAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAsyncWithHttpInfo
     *
     * GetStatus
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsyncWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusGet200TextPlainResponse';
        $request = $this->getStatusRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatus'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusRequest($ocp_apim_subscription_key = null)
    {

        $resourcePath = '/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatusAbout
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsStatusResponse
     */
    public function getStatusAbout($ocp_apim_subscription_key = null)
    {
        list($response) = $this->getStatusAboutWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation getStatusAboutWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsStatusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusAboutWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAboutAsync
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsync($ocp_apim_subscription_key = null)
    {
        return $this->getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAboutAsyncWithHttpInfo
     *
     * GetStatusAbout
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAboutAsyncWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsStatusResponse';
        $request = $this->getStatusAboutRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatusAbout'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusAboutRequest($ocp_apim_subscription_key = null)
    {

        $resourcePath = '/status/about';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageObject
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObject
     */
    public function imageObject($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->imageObjectWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation imageObjectWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageObjectWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageObjectAsync
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->imageObjectAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageObjectAsyncWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObject';
        $request = $this->imageObjectRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageObject'
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageObjectRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling imageObject'
            );
        }

        $resourcePath = '/imageObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAdministrativeAreaRegion
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreasResponse
     */
    public function listAdministrativeAreaRegion($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listAdministrativeAreaRegionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listAdministrativeAreaRegionWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAdministrativeAreaRegionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAdministrativeAreaRegionAsync
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listAdministrativeAreaRegionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAdministrativeAreaRegion'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAdministrativeAreaRegionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/areas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategory
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCategoriesResponse
     */
    public function listCategory($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        list($response) = $this->listCategoryWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $ocp_apim_subscription_key, $accept_language);
        return $response;
    }

    /**
     * Operation listCategoryWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCategoriesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $ocp_apim_subscription_key, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCategoriesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCategoryAsync
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsync($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        return $this->listCategoryAsyncWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $ocp_apim_subscription_key, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryAsyncWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsyncWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $ocp_apim_subscription_key, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategory'
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCategoryRequest($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {

        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_category !== null) {
            $queryParams['parentCategory'] = ObjectSerializer::toQueryValue($parent_category);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCivicStructure
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCivicStructuresResponse
     */
    public function listCivicStructure($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCivicStructureWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCivicStructureWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCivicStructuresResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCivicStructureWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCivicStructuresResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCivicStructureAsync
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCivicStructureAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCivicStructureAsyncWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCivicStructure'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCivicStructureRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/civicStructures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCondition
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsConditionsResponse
     */
    public function listCondition($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listConditionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listConditionWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsConditionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConditionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsConditionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConditionAsync
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listConditionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConditionAsyncWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCondition'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConditionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/conditions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreativeWork
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsCreativeWorksResponse
     */
    public function listCreativeWork($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCreativeWorkWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCreativeWorkWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsCreativeWorksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreativeWorkWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsCreativeWorksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreativeWorkAsync
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCreativeWorkAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreativeWorkAsyncWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsCreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreativeWork'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCreativeWorkRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/creativeWorks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEvents
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsEventsResponse
     */
    public function listEvents($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listEventsWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listEventsWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsEventsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEventsWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsEventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEventsAsync
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsync($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listEventsAsyncWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEventsAsyncWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsyncWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsEventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEvents'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listEventsRequest($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFoodEstablishment
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsFoodEstablishmentsResponse
     */
    public function listFoodEstablishment($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listFoodEstablishmentWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listFoodEstablishmentWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsFoodEstablishmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFoodEstablishmentWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsFoodEstablishmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFoodEstablishmentAsync
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listFoodEstablishmentAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFoodEstablishmentAsyncWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsFoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFoodEstablishment'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFoodEstablishmentRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/foodEstablishments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listImageObject
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsImageObjectsResponse
     */
    public function listImageObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listImageObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listImageObjectWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsImageObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listImageObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsImageObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listImageObjectAsync
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listImageObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listImageObjectAsyncWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listImageObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listImageObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/imageObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLocalBusiness
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusinessesResponse
     */
    public function listLocalBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLocalBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLocalBusinessWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLocalBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLocalBusinessAsync
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLocalBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLocalBusinessAsyncWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLocalBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLocalBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/localbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLodgingBusiness
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusinessesResponse
     */
    public function listLodgingBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLodgingBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLodgingBusinessWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLodgingBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLodgingBusinessAsync
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLodgingBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLodgingBusinessAsyncWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLodgingBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLodgingBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/lodgingbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMediaObject
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsMediaObjectsResponse
     */
    public function listMediaObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listMediaObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listMediaObjectWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsMediaObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMediaObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsMediaObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMediaObjectAsync
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listMediaObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMediaObjectAsyncWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsMediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMediaObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMediaObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/mediaObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPlace
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlacesResponse
     */
    public function listPlace($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listPlaceWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listPlaceWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlacesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPlaceWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlacesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPlaceAsync
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listPlaceAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPlaceAsyncWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPlace'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPlaceRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/places';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProducts
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProductsResponse
     */
    public function listProducts($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        list($response) = $this->listProductsWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language);
        return $response;
    }

    /**
     * Operation listProductsWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProductsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProductsWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProductsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProductsAsync
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsync($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        return $this->listProductsAsyncWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProductsAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsyncWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProducts'
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProductsRequest($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null)
    {

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTag
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTagsResponse
     */
    public function listTag($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTagWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTagWithHttpInfo
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTagsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTagWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTagsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTagAsync
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTagAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTagAsyncWithHttpInfo
     *
     * List Tag
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTagAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTagsResponse';
        $request = $this->listTagRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTag'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTagRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTimezones
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTimeZoneResponseArray
     */
    public function listTimezones($ocp_apim_subscription_key = null)
    {
        list($response) = $this->listTimezonesWithHttpInfo($ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation listTimezonesWithHttpInfo
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTimeZoneResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTimezonesWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest($ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTimeZoneResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTimezonesAsync
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsync($ocp_apim_subscription_key = null)
    {
        return $this->listTimezonesAsyncWithHttpInfo($ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTimezonesAsyncWithHttpInfo
     *
     * List Timezones
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsyncWithHttpInfo($ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTimeZoneResponseArray';
        $request = $this->listTimezonesRequest($ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTimezones'
     *
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTimezonesRequest($ocp_apim_subscription_key = null)
    {

        $resourcePath = '/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTour
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsToursResponse
     */
    public function listTour($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTourWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTourWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsToursResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTourWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsToursResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTourAsync
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTourAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTourAsyncWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTour'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTourRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/tours';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebcams
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcamsResponse
     */
    public function listWebcams($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listWebcamsWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listWebcamsWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcamsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebcamsWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcamsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebcamsAsync
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listWebcamsAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebcamsAsyncWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebcams'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listWebcamsRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/webcams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusiness
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLocalBusiness
     */
    public function localBusiness($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLocalBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLocalBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessAsync
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessAsyncWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLocalBusiness';
        $request = $this->localBusinessRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusiness'
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusiness'
            );
        }

        $resourcePath = '/localbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessDailyForecast
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function localBusinessDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessDailyForecastWithHttpInfo
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->localBusinessDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessDailyForecastAsync
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessDailyForecastAsyncWithHttpInfo
     *
     * LocalBusiness daily forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->localBusinessDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessDailyForecast'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessDailyForecast'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessHourlyForecast
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function localBusinessHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessHourlyForecastWithHttpInfo
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->localBusinessHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessHourlyForecastAsync
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessHourlyForecastAsyncWithHttpInfo
     *
     * LocalBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->localBusinessHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessHourlyForecast'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessHourlyForecast'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusinessWeather
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function localBusinessWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessWeatherWithHttpInfo
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->localBusinessWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessWeatherAsync
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessWeatherAsyncWithHttpInfo
     *
     * LocalBusiness weather
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->localBusinessWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusinessWeather'
     *
     * @param  string $id Use property identifier of LocalBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusinessWeather'
            );
        }

        $resourcePath = '/localbusinesses/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusiness
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsLodgingBusiness
     */
    public function lodgingBusiness($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsLodgingBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsLodgingBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessAsync
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessAsyncWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsLodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusiness'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusiness'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessDailyForecast
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function lodgingBusinessDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessDailyForecastWithHttpInfo
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->lodgingBusinessDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessDailyForecastAsync
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessDailyForecastAsyncWithHttpInfo
     *
     * LodgingBusiness daily forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->lodgingBusinessDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessDailyForecast'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessDailyForecast'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessHourlyForecast
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function lodgingBusinessHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessHourlyForecastWithHttpInfo
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->lodgingBusinessHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessHourlyForecastAsync
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessHourlyForecastAsyncWithHttpInfo
     *
     * LodgingBusiness hourly forecast
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->lodgingBusinessHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessHourlyForecast'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessHourlyForecast'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusinessWeather
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function lodgingBusinessWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessWeatherWithHttpInfo
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->lodgingBusinessWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessWeatherAsync
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessWeatherAsyncWithHttpInfo
     *
     * LodgingBusiness weather
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->lodgingBusinessWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusinessWeather'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusinessWeather'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mediaObject
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function mediaObject($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->mediaObjectWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation mediaObjectWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function mediaObjectWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->mediaObjectRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mediaObjectAsync
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->mediaObjectAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mediaObjectAsyncWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->mediaObjectRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mediaObject'
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mediaObjectRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling mediaObject'
            );
        }

        $resourcePath = '/mediaObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation place
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsPlace
     */
    public function place($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsPlace, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsPlace',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeAsync
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeAsyncWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsPlace';
        $request = $this->placeRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'place'
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling place'
            );
        }

        $resourcePath = '/places/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeDailyForecast
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function placeDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeDailyForecastWithHttpInfo
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->placeDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeDailyForecastAsync
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeDailyForecastAsyncWithHttpInfo
     *
     * Place daily forecast
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->placeDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeDailyForecast'
     *
     * @param  string $id Use property identifier of Place to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeDailyForecast'
            );
        }

        $resourcePath = '/places/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeHourlyForecast
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function placeHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeHourlyForecastWithHttpInfo
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->placeHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeHourlyForecastAsync
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeHourlyForecastAsyncWithHttpInfo
     *
     * Place hourly forecast
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->placeHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeHourlyForecast'
     *
     * @param  string $id Use property identifier of Place to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeHourlyForecast'
            );
        }

        $resourcePath = '/places/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation placeWeather
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function placeWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeWeatherWithHttpInfo
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->placeWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeWeatherAsync
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeWeatherAsyncWithHttpInfo
     *
     * Place weather
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->placeWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'placeWeather'
     *
     * @param  string $id Use property identifier of Place to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling placeWeather'
            );
        }

        $resourcePath = '/places/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation product
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsProduct
     */
    public function product($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->productWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation productWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function productWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAsync
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->productAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAsyncWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsProduct';
        $request = $this->productRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'product'
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling product'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function search($body = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchWithHttpInfo($body, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($body, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($body = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchAsyncWithHttpInfo($body, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($body = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchRequest($body, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  \Infocenter\Client\Model\DsFullSearchRequest $body (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($body = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByGET
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and additionalType (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $campaign_tag Use property for filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag/id&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;seasons&#x60; (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsSearchResponse
     */
    public function searchByGET($search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $leaf_type = null, $campaign_tag = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchByGETWithHttpInfo($search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $leaf_type, $campaign_tag, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchByGETWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and additionalType (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $campaign_tag Use property for filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag/id&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;seasons&#x60; (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByGETWithHttpInfo($search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $leaf_type = null, $campaign_tag = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $leaf_type, $campaign_tag, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByGETAsync
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and additionalType (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $campaign_tag Use property for filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag/id&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;seasons&#x60; (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsync($search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $leaf_type = null, $campaign_tag = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchByGETAsyncWithHttpInfo($search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $leaf_type, $campaign_tag, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByGETAsyncWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and additionalType (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $campaign_tag Use property for filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag/id&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;seasons&#x60; (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsyncWithHttpInfo($search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $leaf_type = null, $campaign_tag = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsSearchResponse';
        $request = $this->searchByGETRequest($search_text, $search_fields, $select, $current_page, $results_per_page, $order_by, $category, $filters, $type, $datasource, $project, $combined_type, $leaf_type, $campaign_tag, $category_tree, $tag, $contained_in_place, $address_locality, $address_postal_code, $time, $state, $rating_condition, $rating_difficulty, $elevation_ascent, $elevation_descent, $elevation_min_altitude, $elevation_max_altitude, $season, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByGET'
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  string $search_fields Use property for selecting of search fields by which necessary to search (optional)
     * @param  string $select Use property for selecting fields which necessary to return in response (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $category Use property for filtering by &#x60;category&#x60; (optional)
     * @param  string $filters Use property for odata filtering (optional)
     * @param  string $type Use property for filtering by &#x60;type&#x60; (optional)
     * @param  string $datasource Use property for filtering by &#x60;dataSource&#x60; (optional)
     * @param  string $project Use property for filtering by &#x60;project&#x60; (optional)
     * @param  string $combined_type Use property for filtering by &#x60;combinedType&#x60; which contains parentType and additionalType (optional)
     * @param  string $leaf_type Use property for filtering by &#x60;leafType&#x60; which contains additionalType or type (optional)
     * @param  string $campaign_tag Use property for filtering by &#x60;campaignTag&#x60; (optional)
     * @param  string $category_tree Use property for filtering/facet-filtering by &#x60;categoryTree&#x60; (optional)
     * @param  string $tag Use property for filtering/facet-filtering by &#x60;tag/id&#x60; (optional)
     * @param  string $contained_in_place Use property for filtering/facet-filtering by &#x60;containedInPlace/id&#x60; (optional)
     * @param  string $address_locality Use property for filtering/facet-filtering by &#x60;address/addressLocality&#x60; (optional)
     * @param  string $address_postal_code Use property for filtering/facet-filtering by &#x60;address/postalCode&#x60; (optional)
     * @param  string $time Use property for filtering/facet-filtering by &#x60;time&#x60; (optional)
     * @param  string $state Use property for filtering/facet-filtering by &#x60;state&#x60; (optional)
     * @param  string $rating_condition Use property for filtering/facet-filtering by &#x60;rating/condition&#x60; (optional)
     * @param  string $rating_difficulty Use property for filtering/facet-filtering by &#x60;rating/difficulty&#x60; (optional)
     * @param  string $elevation_ascent Use property for filtering/facet-filtering by &#x60;elevation/ascent&#x60; (optional)
     * @param  string $elevation_descent Use property for filtering/facet-filtering by &#x60;elevation/descent&#x60; (optional)
     * @param  string $elevation_min_altitude Use property for filtering/facet-filtering by &#x60;elevation/minAltitude&#x60; (optional)
     * @param  string $elevation_max_altitude Use property for filtering/facet-filtering by &#x60;elevation/maxAltitude&#x60; (optional)
     * @param  string $season Use property for filtering/facet-filtering by &#x60;seasons&#x60; (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByGETRequest($search_text = null, $search_fields = null, $select = null, $current_page = null, $results_per_page = null, $order_by = null, $category = null, $filters = null, $type = null, $datasource = null, $project = null, $combined_type = null, $leaf_type = null, $campaign_tag = null, $category_tree = null, $tag = null, $contained_in_place = null, $address_locality = null, $address_postal_code = null, $time = null, $state = null, $rating_condition = null, $rating_difficulty = null, $elevation_ascent = null, $elevation_descent = null, $elevation_min_altitude = null, $elevation_max_altitude = null, $season = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($search_text);
        }
        // query params
        if ($search_fields !== null) {
            $queryParams['searchFields'] = ObjectSerializer::toQueryValue($search_fields);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($current_page !== null) {
            $queryParams['currentPage'] = ObjectSerializer::toQueryValue($current_page);
        }
        // query params
        if ($results_per_page !== null) {
            $queryParams['resultsPerPage'] = ObjectSerializer::toQueryValue($results_per_page);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($filters !== null) {
            $queryParams['filters'] = ObjectSerializer::toQueryValue($filters);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($combined_type !== null) {
            $queryParams['combinedType'] = ObjectSerializer::toQueryValue($combined_type);
        }
        // query params
        if ($leaf_type !== null) {
            $queryParams['leafType'] = ObjectSerializer::toQueryValue($leaf_type);
        }
        // query params
        if ($campaign_tag !== null) {
            $queryParams['campaignTag'] = ObjectSerializer::toQueryValue($campaign_tag);
        }
        // query params
        if ($category_tree !== null) {
            $queryParams['categoryTree'] = ObjectSerializer::toQueryValue($category_tree);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($address_locality !== null) {
            $queryParams['addressLocality'] = ObjectSerializer::toQueryValue($address_locality);
        }
        // query params
        if ($address_postal_code !== null) {
            $queryParams['addressPostalCode'] = ObjectSerializer::toQueryValue($address_postal_code);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = ObjectSerializer::toQueryValue($time);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = ObjectSerializer::toQueryValue($state);
        }
        // query params
        if ($rating_condition !== null) {
            $queryParams['ratingCondition'] = ObjectSerializer::toQueryValue($rating_condition);
        }
        // query params
        if ($rating_difficulty !== null) {
            $queryParams['ratingDifficulty'] = ObjectSerializer::toQueryValue($rating_difficulty);
        }
        // query params
        if ($elevation_ascent !== null) {
            $queryParams['elevationAscent'] = ObjectSerializer::toQueryValue($elevation_ascent);
        }
        // query params
        if ($elevation_descent !== null) {
            $queryParams['elevationDescent'] = ObjectSerializer::toQueryValue($elevation_descent);
        }
        // query params
        if ($elevation_min_altitude !== null) {
            $queryParams['elevationMinAltitude'] = ObjectSerializer::toQueryValue($elevation_min_altitude);
        }
        // query params
        if ($elevation_max_altitude !== null) {
            $queryParams['elevationMaxAltitude'] = ObjectSerializer::toQueryValue($elevation_max_altitude);
        }
        // query params
        if ($season !== null) {
            $queryParams['season'] = ObjectSerializer::toQueryValue($season);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tag
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTag
     */
    public function tag($id, $project = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tagWithHttpInfo($id, $project, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tagWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTag, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagWithHttpInfo($id, $project = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $project, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tagAsync
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsync($id, $project = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tagAsyncWithHttpInfo($id, $project, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagAsyncWithHttpInfo
     *
     * Tag
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagAsyncWithHttpInfo($id, $project = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTag';
        $request = $this->tagRequest($id, $project, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tag'
     *
     * @param  string $id Use property identifier of Tag to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagRequest($id, $project = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tag'
            );
        }

        $resourcePath = '/tags/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termVersion
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTermVersion
     */
    public function termVersion($code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->termVersionWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation termVersionWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function termVersionWithHttpInfo($code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation termVersionAsync
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsync($code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->termVersionAsyncWithHttpInfo($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termVersionAsyncWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsyncWithHttpInfo($code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTermVersion';
        $request = $this->termVersionRequest($code, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termVersion'
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termVersionRequest($code, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling termVersion'
            );
        }

        $resourcePath = '/termversions/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tour
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsTour
     */
    public function tour($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsTour, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsTour',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourAsync
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourAsyncWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsTour';
        $request = $this->tourRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tour'
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tour'
            );
        }

        $resourcePath = '/tours/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourDailyForecast
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function tourDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourDailyForecastWithHttpInfo
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->tourDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourDailyForecastAsync
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourDailyForecastAsyncWithHttpInfo
     *
     * Tour daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->tourDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourDailyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourDailyForecast'
            );
        }

        $resourcePath = '/tours/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourDownload
     *
     * Tour download
     *
     * @param  string $id Use property identifier of Tour to get the map file with given extension. (required)
     * @param  string $extension Tour map format (kml or gpx). (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsToursIdDownloadExtensionGet200ApplicationJsonResponse
     */
    public function tourDownload($id, $extension, $ocp_apim_subscription_key = null)
    {
        list($response) = $this->tourDownloadWithHttpInfo($id, $extension, $ocp_apim_subscription_key);
        return $response;
    }

    /**
     * Operation tourDownloadWithHttpInfo
     *
     * Tour download
     *
     * @param  string $id Use property identifier of Tour to get the map file with given extension. (required)
     * @param  string $extension Tour map format (kml or gpx). (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsToursIdDownloadExtensionGet200ApplicationJsonResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourDownloadWithHttpInfo($id, $extension, $ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursIdDownloadExtensionGet200ApplicationJsonResponse';
        $request = $this->tourDownloadRequest($id, $extension, $ocp_apim_subscription_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsToursIdDownloadExtensionGet200ApplicationJsonResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourDownloadAsync
     *
     * Tour download
     *
     * @param  string $id Use property identifier of Tour to get the map file with given extension. (required)
     * @param  string $extension Tour map format (kml or gpx). (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDownloadAsync($id, $extension, $ocp_apim_subscription_key = null)
    {
        return $this->tourDownloadAsyncWithHttpInfo($id, $extension, $ocp_apim_subscription_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourDownloadAsyncWithHttpInfo
     *
     * Tour download
     *
     * @param  string $id Use property identifier of Tour to get the map file with given extension. (required)
     * @param  string $extension Tour map format (kml or gpx). (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourDownloadAsyncWithHttpInfo($id, $extension, $ocp_apim_subscription_key = null)
    {
        $returnType = '\Infocenter\Client\Model\DsToursIdDownloadExtensionGet200ApplicationJsonResponse';
        $request = $this->tourDownloadRequest($id, $extension, $ocp_apim_subscription_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourDownload'
     *
     * @param  string $id Use property identifier of Tour to get the map file with given extension. (required)
     * @param  string $extension Tour map format (kml or gpx). (required)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourDownloadRequest($id, $extension, $ocp_apim_subscription_key = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourDownload'
            );
        }
        // verify the required parameter 'extension' is set
        if ($extension === null || (is_array($extension) && count($extension) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extension when calling tourDownload'
            );
        }

        $resourcePath = '/tours/{id}/download/{extension}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($extension !== null) {
            $resourcePath = str_replace(
                '{' . 'extension' . '}',
                ObjectSerializer::toPathValue($extension),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourHourlyForecast
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function tourHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourHourlyForecastWithHttpInfo
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->tourHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourHourlyForecastAsync
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourHourlyForecastAsyncWithHttpInfo
     *
     * Tour hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->tourHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourHourlyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather hourly forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourHourlyForecast'
            );
        }

        $resourcePath = '/tours/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tourWeather
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function tourWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourWeatherWithHttpInfo
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->tourWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourWeatherAsync
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourWeatherAsyncWithHttpInfo
     *
     * Tour weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->tourWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tourWeather'
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tourWeather'
            );
        }

        $resourcePath = '/tours/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation treeAdministrativeAreaRegion
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsAdministrativeAreaTreeItem
     */
    public function treeAdministrativeAreaRegion($id, $levels = null, $admin_areas_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->treeAdministrativeAreaRegionWithHttpInfo($id, $levels, $admin_areas_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation treeAdministrativeAreaRegionWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsAdministrativeAreaTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function treeAdministrativeAreaRegionWithHttpInfo($id, $levels = null, $admin_areas_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation treeAdministrativeAreaRegionAsync
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsync($id, $levels = null, $admin_areas_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels, $admin_areas_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation treeAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels = null, $admin_areas_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\DsAdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $ocp_apim_subscription_key, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'treeAdministrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function treeAdministrativeAreaRegionRequest($id, $levels = null, $admin_areas_only = null, $ocp_apim_subscription_key = null, $accept_timezone = null, $accept_language = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling treeAdministrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($levels !== null) {
            $queryParams['levels'] = ObjectSerializer::toQueryValue($levels);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcam
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWebcam
     */
    public function webcam($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWebcam, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWebcam',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamAsync
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsync($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamAsyncWithHttpInfo($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamAsyncWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWebcam';
        $request = $this->webcamRequest($id, $project, $contained_in_place, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcam'
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamRequest($id, $project = null, $contained_in_place = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcam'
            );
        }

        $resourcePath = '/webcams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamDailyForecast
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsDailyForecastArray
     */
    public function webcamDailyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamDailyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamDailyForecastWithHttpInfo
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsDailyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamDailyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->webcamDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsDailyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamDailyForecastAsync
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamDailyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamDailyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamDailyForecastAsyncWithHttpInfo
     *
     * Webcam daily forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamDailyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsDailyForecastArray';
        $request = $this->webcamDailyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamDailyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamDailyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamDailyForecast'
            );
        }

        $resourcePath = '/webcams/{id}/weather/forecast/daily';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamHourlyForecast
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsHourlyForecastArray
     */
    public function webcamHourlyForecast($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamHourlyForecastWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamHourlyForecastWithHttpInfo
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsHourlyForecastArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamHourlyForecastWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->webcamHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsHourlyForecastArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamHourlyForecastAsync
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamHourlyForecastAsync($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamHourlyForecastAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamHourlyForecastAsyncWithHttpInfo
     *
     * Webcam hourly forecast
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamHourlyForecastAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsHourlyForecastArray';
        $request = $this->webcamHourlyForecastRequest($id, $project, $contained_in_place, $duration, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamHourlyForecast'
     *
     * @param  string $id Use property identifier of Webcam to get the weather daily forecast information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamHourlyForecastRequest($id, $project = null, $contained_in_place = null, $duration = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamHourlyForecast'
            );
        }

        $resourcePath = '/webcams/{id}/weather/forecast/hourly';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcamWeather
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\DsWeatherArray
     */
    public function webcamWeather($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamWeatherWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamWeatherWithHttpInfo
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\DsWeatherArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWeatherWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->webcamWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\DsWeatherArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamWeatherAsync
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamWeatherAsync($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamWeatherAsyncWithHttpInfo($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamWeatherAsyncWithHttpInfo
     *
     * Webcam weather
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamWeatherAsyncWithHttpInfo($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\DsWeatherArray';
        $request = $this->webcamWeatherRequest($id, $project, $contained_in_place, $duration, $details, $ocp_apim_subscription_key, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcamWeather'
     *
     * @param  string $id Use property identifier of Webcam to get the weather information for it. (required)
     * @param  string $project Use this property to filter objects by project. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  int $duration Format - int32. Supply number of past hours to get data for (optional)
     * @param  bool $details Supply &#x27;true&#x27; if you want to get detailed information about the weather (optional)
     * @param  string $ocp_apim_subscription_key Subscription key to access the api. Get it on developer.discover.swiss. (optional)
     * @param  string $accept_language Two-letter language code to get localized properties. (optional)
     * @param  string $accept_timezone Time zone ID to apply its offset to dates and time (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamWeatherRequest($id, $project = null, $contained_in_place = null, $duration = null, $details = null, $ocp_apim_subscription_key = null, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcamWeather'
            );
        }

        $resourcePath = '/webcams/{id}/weather';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = ObjectSerializer::toQueryValue($details);
        }
        // header params
        if ($ocp_apim_subscription_key !== null) {
            $headerParams['Ocp-Apim-Subscription-Key'] = ObjectSerializer::toHeaderValue($ocp_apim_subscription_key);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
