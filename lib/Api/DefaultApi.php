<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Infocenter-TEST
 *
 * Infocenter-TEST
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.20
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Infocenter\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Infocenter\Client\ApiException;
use Infocenter\Client\Configuration;
use Infocenter\Client\HeaderSelector;
use Infocenter\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Infocenter\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation administrativeAreaRegion
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\AdministrativeArea
     */
    public function administrativeAreaRegion($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->administrativeAreaRegionWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation administrativeAreaRegionWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\AdministrativeArea, HTTP status code, HTTP response headers (array of strings)
     */
    public function administrativeAreaRegionWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\AdministrativeArea',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation administrativeAreaRegionAsync
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->administrativeAreaRegionAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation administrativeAreaRegionAsyncWithHttpInfo
     *
     * AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function administrativeAreaRegionAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeArea';
        $request = $this->administrativeAreaRegionRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'administrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function administrativeAreaRegionRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling administrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation category
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Category
     */
    public function category($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Category, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Category';
        $request = $this->categoryRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Category',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryAsync
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryAsyncWithHttpInfo
     *
     * Category
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Category';
        $request = $this->categoryRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'category'
     *
     * @param  string $id Use property identifier of Category to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling category'
            );
        }

        $resourcePath = '/categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation categoryTree
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CategoryTreeItem
     */
    public function categoryTree($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->categoryTreeWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation categoryTreeWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CategoryTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryTreeWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CategoryTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryTreeAsync
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->categoryTreeAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryTreeAsyncWithHttpInfo
     *
     * Category Tree
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryTreeAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CategoryTreeItem';
        $request = $this->categoryTreeRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryTree'
     *
     * @param  string $id Use property identifier of Category to set root category. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryTreeRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling categoryTree'
            );
        }

        $resourcePath = '/categories/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation civicStructure
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CivicStructure
     */
    public function civicStructure($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->civicStructureWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation civicStructureWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CivicStructure, HTTP status code, HTTP response headers (array of strings)
     */
    public function civicStructureWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CivicStructure';
        $request = $this->civicStructureRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CivicStructure',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation civicStructureAsync
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->civicStructureAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation civicStructureAsyncWithHttpInfo
     *
     * CivicStructure
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function civicStructureAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CivicStructure';
        $request = $this->civicStructureRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'civicStructure'
     *
     * @param  string $id Use property identifier of CivicStructure to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function civicStructureRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling civicStructure'
            );
        }

        $resourcePath = '/civicStructures/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation condition
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Condition
     */
    public function condition($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->conditionWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation conditionWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Condition, HTTP status code, HTTP response headers (array of strings)
     */
    public function conditionWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Condition';
        $request = $this->conditionRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Condition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation conditionAsync
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->conditionAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation conditionAsyncWithHttpInfo
     *
     * Condition
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function conditionAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Condition';
        $request = $this->conditionRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'condition'
     *
     * @param  string $id Use property identifier of Condition to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function conditionRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling condition'
            );
        }

        $resourcePath = '/conditions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creativeWork
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CreativeWork
     */
    public function creativeWork($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->creativeWorkWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation creativeWorkWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CreativeWork, HTTP status code, HTTP response headers (array of strings)
     */
    public function creativeWorkWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CreativeWork';
        $request = $this->creativeWorkRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CreativeWork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation creativeWorkAsync
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->creativeWorkAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creativeWorkAsyncWithHttpInfo
     *
     * CreativeWork
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creativeWorkAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CreativeWork';
        $request = $this->creativeWorkRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creativeWork'
     *
     * @param  string $id Use property identifier of CreativeWork to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creativeWorkRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creativeWork'
            );
        }

        $resourcePath = '/creativeWorks/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation currentTermVersion
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\TermVersion
     */
    public function currentTermVersion($term_code, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->currentTermVersionWithHttpInfo($term_code, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation currentTermVersionWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\TermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function currentTermVersionWithHttpInfo($term_code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\TermVersion';
        $request = $this->currentTermVersionRequest($term_code, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\TermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation currentTermVersionAsync
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsync($term_code, $accept_language = null, $accept_timezone = null)
    {
        return $this->currentTermVersionAsyncWithHttpInfo($term_code, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation currentTermVersionAsyncWithHttpInfo
     *
     * Current TermVersion
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function currentTermVersionAsyncWithHttpInfo($term_code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\TermVersion';
        $request = $this->currentTermVersionRequest($term_code, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'currentTermVersion'
     *
     * @param  string $term_code Use property code of a term to get the current term version. (required)
     * @param  string $accept_language Supply this header to select the term version in the correct language and deliver localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function currentTermVersionRequest($term_code, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'term_code' is set
        if ($term_code === null || (is_array($term_code) && count($term_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term_code when calling currentTermVersion'
            );
        }

        $resourcePath = '/termversions/{termCode}/currentVersion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($term_code !== null) {
            $resourcePath = str_replace(
                '{' . 'termCode' . '}',
                ObjectSerializer::toPathValue($term_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation event
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Event
     */
    public function event($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->eventWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation eventWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Event, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Event';
        $request = $this->eventRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Event',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventAsync
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->eventAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventAsyncWithHttpInfo
     *
     * Event
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Event';
        $request = $this->eventRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'event'
     *
     * @param  string $id Use property identifier of Event to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling event'
            );
        }

        $resourcePath = '/events/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation foodEstablishment
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\FoodEstablishment
     */
    public function foodEstablishment($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->foodEstablishmentWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation foodEstablishmentWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\FoodEstablishment, HTTP status code, HTTP response headers (array of strings)
     */
    public function foodEstablishmentWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\FoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\FoodEstablishment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation foodEstablishmentAsync
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->foodEstablishmentAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation foodEstablishmentAsyncWithHttpInfo
     *
     * FoodEstablishment
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function foodEstablishmentAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\FoodEstablishment';
        $request = $this->foodEstablishmentRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'foodEstablishment'
     *
     * @param  string $id Use property identifier of FoodEstablishment to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function foodEstablishmentRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling foodEstablishment'
            );
        }

        $resourcePath = '/foodEstablishments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStatus
     *
     * GetStatus
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getStatus()
    {
        $this->getStatusWithHttpInfo();
    }

    /**
     * Operation getStatusWithHttpInfo
     *
     * GetStatus
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStatusWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getStatusRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getStatusAsync
     *
     * GetStatus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsync()
    {
        return $this->getStatusAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStatusAsyncWithHttpInfo
     *
     * GetStatus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStatusAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getStatusRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStatus'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStatusRequest()
    {

        $resourcePath = '/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageObject
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\ImageObject
     */
    public function imageObject($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->imageObjectWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation imageObjectWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\ImageObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageObjectWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ImageObject';
        $request = $this->imageObjectRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\ImageObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageObjectAsync
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->imageObjectAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageObjectAsyncWithHttpInfo
     *
     * ImageObject
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageObjectAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ImageObject';
        $request = $this->imageObjectRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageObject'
     *
     * @param  string $id Use property identifier of ImageObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function imageObjectRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling imageObject'
            );
        }

        $resourcePath = '/imageObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAdministrativeAreaRegion
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\AdministrativeAreasResponse
     */
    public function listAdministrativeAreaRegion($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listAdministrativeAreaRegionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listAdministrativeAreaRegionWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\AdministrativeAreasResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAdministrativeAreaRegionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\AdministrativeAreasResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAdministrativeAreaRegionAsync
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listAdministrativeAreaRegionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * List AdministrativeArea (Region)
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAdministrativeAreaRegionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeAreasResponse';
        $request = $this->listAdministrativeAreaRegionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $admin_areas_only, $root_objects_only, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAdministrativeAreaRegion'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (works only in combination with rootObjectsOnly). (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root areas. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAdministrativeAreaRegionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $admin_areas_only = null, $root_objects_only = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/areas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCategory
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CategoriesResponse
     */
    public function listCategory($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        list($response) = $this->listCategoryWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);
        return $response;
    }

    /**
     * Operation listCategoryWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CategoriesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCategoryWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\CategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CategoriesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCategoryAsync
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsync($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        return $this->listCategoryAsyncWithHttpInfo($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCategoryAsyncWithHttpInfo
     *
     * List Category
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCategoryAsyncWithHttpInfo($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\CategoriesResponse';
        $request = $this->listCategoryRequest($parent_category, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $root_objects_only, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCategory'
     *
     * @param  string $parent_category Use property identifier of category to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  bool $root_objects_only Pass &#x27;true&#x27; if you want to get only root categories. (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCategoryRequest($parent_category = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $root_objects_only = null, $accept_language = null)
    {

        $resourcePath = '/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_category !== null) {
            $queryParams['parentCategory'] = ObjectSerializer::toQueryValue($parent_category);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // query params
        if ($root_objects_only !== null) {
            $queryParams['rootObjectsOnly'] = ObjectSerializer::toQueryValue($root_objects_only);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCivicStructure
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CivicStructuresResponse
     */
    public function listCivicStructure($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCivicStructureWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCivicStructureWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CivicStructuresResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCivicStructureWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CivicStructuresResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCivicStructureAsync
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCivicStructureAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCivicStructureAsyncWithHttpInfo
     *
     * List CivicStructure
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCivicStructureAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CivicStructuresResponse';
        $request = $this->listCivicStructureRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCivicStructure'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCivicStructureRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/civicStructures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCondition
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\ConditionsResponse
     */
    public function listCondition($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listConditionWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listConditionWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\ConditionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConditionWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\ConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\ConditionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConditionAsync
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listConditionAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConditionAsyncWithHttpInfo
     *
     * List Condition
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConditionAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\ConditionsResponse';
        $request = $this->listConditionRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCondition'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listConditionRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/conditions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreativeWork
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\CreativeWorksResponse
     */
    public function listCreativeWork($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listCreativeWorkWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listCreativeWorkWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\CreativeWorksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreativeWorkWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\CreativeWorksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreativeWorkAsync
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listCreativeWorkAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreativeWorkAsyncWithHttpInfo
     *
     * List CreativeWork
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreativeWorkAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\CreativeWorksResponse';
        $request = $this->listCreativeWorkRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreativeWork'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCreativeWorkRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/creativeWorks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEvents
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\EventsResponse
     */
    public function listEvents($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->listEventsWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation listEventsWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\EventsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEventsWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\EventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\EventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEventsAsync
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsync($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->listEventsAsyncWithHttpInfo($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEventsAsyncWithHttpInfo
     *
     * List Events
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEventsAsyncWithHttpInfo($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\EventsResponse';
        $request = $this->listEventsRequest($updated_since, $category, $datasource, $continuation_token, $top, $contained_in_place, $location, $project, $select, $include_count, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEvents'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter by the region (administrative area). (optional)
     * @param  string $location Use property identifier of place to filter by the location (business). (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listEventsRequest($updated_since = null, $category = null, $datasource = null, $continuation_token = null, $top = null, $contained_in_place = null, $location = null, $project = null, $select = null, $include_count = null, $accept_timezone = null, $accept_language = null)
    {

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($location !== null) {
            $queryParams['location'] = ObjectSerializer::toQueryValue($location);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFoodEstablishment
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\FoodEstablishmentsResponse
     */
    public function listFoodEstablishment($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listFoodEstablishmentWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listFoodEstablishmentWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\FoodEstablishmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFoodEstablishmentWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\FoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\FoodEstablishmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFoodEstablishmentAsync
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listFoodEstablishmentAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFoodEstablishmentAsyncWithHttpInfo
     *
     * List FoodEstablishment
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFoodEstablishmentAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\FoodEstablishmentsResponse';
        $request = $this->listFoodEstablishmentRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFoodEstablishment'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFoodEstablishmentRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/foodEstablishments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listImageObject
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\ImageObjectsResponse
     */
    public function listImageObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listImageObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listImageObjectWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\ImageObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listImageObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\ImageObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listImageObjectAsync
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listImageObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listImageObjectAsyncWithHttpInfo
     *
     * List ImageObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listImageObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ImageObjectsResponse';
        $request = $this->listImageObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listImageObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listImageObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/imageObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLocalBusiness
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\LocalBusinessesResponse
     */
    public function listLocalBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLocalBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLocalBusinessWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\LocalBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLocalBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\LocalBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLocalBusinessAsync
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLocalBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLocalBusinessAsyncWithHttpInfo
     *
     * List LocalBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLocalBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LocalBusinessesResponse';
        $request = $this->listLocalBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLocalBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLocalBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/localbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listLodgingBusiness
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\LodgingBusinessesResponse
     */
    public function listLodgingBusiness($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listLodgingBusinessWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listLodgingBusinessWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\LodgingBusinessesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listLodgingBusinessWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\LodgingBusinessesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listLodgingBusinessAsync
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listLodgingBusinessAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listLodgingBusinessAsyncWithHttpInfo
     *
     * List LodgingBusiness
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listLodgingBusinessAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LodgingBusinessesResponse';
        $request = $this->listLodgingBusinessRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listLodgingBusiness'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listLodgingBusinessRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/lodgingbusinesses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMediaObject
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\MediaObjectsResponse
     */
    public function listMediaObject($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listMediaObjectWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listMediaObjectWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\MediaObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMediaObjectWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\MediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\MediaObjectsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMediaObjectAsync
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsync($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listMediaObjectAsyncWithHttpInfo($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMediaObjectAsyncWithHttpInfo
     *
     * List MediaObject
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMediaObjectAsyncWithHttpInfo($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\MediaObjectsResponse';
        $request = $this->listMediaObjectRequest($updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMediaObject'
     *
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listMediaObjectRequest($updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/mediaObjects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPlace
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\PlacesResponse
     */
    public function listPlace($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listPlaceWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listPlaceWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\PlacesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPlaceWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\PlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\PlacesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPlaceAsync
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listPlaceAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPlaceAsyncWithHttpInfo
     *
     * List Place
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPlaceAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\PlacesResponse';
        $request = $this->listPlaceRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPlace'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPlaceRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/places';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProducts
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\ProductsResponse
     */
    public function listProducts($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        list($response) = $this->listProductsWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);
        return $response;
    }

    /**
     * Operation listProductsWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\ProductsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProductsWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\ProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\ProductsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProductsAsync
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsync($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        return $this->listProductsAsyncWithHttpInfo($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProductsAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listProductsAsyncWithHttpInfo($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\ProductsResponse';
        $request = $this->listProductsRequest($datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProducts'
     *
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of Data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listProductsRequest($datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null)
    {

        $resourcePath = '/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTimezones
     *
     * List Timezones
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\TimeZoneResponseArray
     */
    public function listTimezones()
    {
        list($response) = $this->listTimezonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation listTimezonesWithHttpInfo
     *
     * List Timezones
     *
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\TimeZoneResponseArray, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTimezonesWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\TimeZoneResponseArray';
        $request = $this->listTimezonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\TimeZoneResponseArray',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTimezonesAsync
     *
     * List Timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsync()
    {
        return $this->listTimezonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTimezonesAsyncWithHttpInfo
     *
     * List Timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTimezonesAsyncWithHttpInfo()
    {
        $returnType = '\Infocenter\Client\Model\TimeZoneResponseArray';
        $request = $this->listTimezonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTimezones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTimezonesRequest()
    {

        $resourcePath = '/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTour
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\ToursResponse
     */
    public function listTour($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listTourWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listTourWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\ToursResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTourWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\ToursResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTourAsync
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listTourAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTourAsyncWithHttpInfo
     *
     * List Tour
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTourAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\ToursResponse';
        $request = $this->listTourRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTour'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listTourRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/tours';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebcams
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\WebcamsResponse
     */
    public function listWebcams($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->listWebcamsWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation listWebcamsWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\WebcamsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebcamsWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\WebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\WebcamsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebcamsAsync
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsync($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->listWebcamsAsyncWithHttpInfo($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebcamsAsyncWithHttpInfo
     *
     * List Webcams
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebcamsAsyncWithHttpInfo($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\WebcamsResponse';
        $request = $this->listWebcamsRequest($category, $contained_in_place, $updated_since, $datasource, $continuation_token, $top, $project, $select, $include_count, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebcams'
     *
     * @param  string $category Use property identifier of category to filter. (optional)
     * @param  string $contained_in_place Use property identifier of place to filter. (optional)
     * @param  string $updated_since Format - date-time (as date-time in RFC3339). Return only changed data since specific date. (optional)
     * @param  string $datasource Use datasource to filter. (optional)
     * @param  string $continuation_token Use it for get next set of data. (optional)
     * @param  int $top Format - int32. Number of next set of entities. (optional)
     * @param  string $project Use this property to filter objects by project (optional)
     * @param  string $select Pass list of object properties to query (optional)
     * @param  bool $include_count Pass &#x27;true&#x27; if you want to get total filtered items count in response (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listWebcamsRequest($category = null, $contained_in_place = null, $updated_since = null, $datasource = null, $continuation_token = null, $top = null, $project = null, $select = null, $include_count = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/webcams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category);
        }
        // query params
        if ($contained_in_place !== null) {
            $queryParams['containedInPlace'] = ObjectSerializer::toQueryValue($contained_in_place);
        }
        // query params
        if ($updated_since !== null) {
            $queryParams['updatedSince'] = ObjectSerializer::toQueryValue($updated_since);
        }
        // query params
        if ($datasource !== null) {
            $queryParams['datasource'] = ObjectSerializer::toQueryValue($datasource);
        }
        // query params
        if ($continuation_token !== null) {
            $queryParams['continuationToken'] = ObjectSerializer::toQueryValue($continuation_token);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($select !== null) {
            $queryParams['select'] = ObjectSerializer::toQueryValue($select);
        }
        // query params
        if ($include_count !== null) {
            $queryParams['includeCount'] = ObjectSerializer::toQueryValue($include_count);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation localBusiness
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\LocalBusiness
     */
    public function localBusiness($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->localBusinessWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation localBusinessWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\LocalBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function localBusinessWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LocalBusiness';
        $request = $this->localBusinessRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\LocalBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation localBusinessAsync
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->localBusinessAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation localBusinessAsyncWithHttpInfo
     *
     * LocalBusiness
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function localBusinessAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LocalBusiness';
        $request = $this->localBusinessRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'localBusiness'
     *
     * @param  string $id Use property identifier of LocalBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function localBusinessRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling localBusiness'
            );
        }

        $resourcePath = '/localbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lodgingBusiness
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\LodgingBusiness
     */
    public function lodgingBusiness($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->lodgingBusinessWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation lodgingBusinessWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\LodgingBusiness, HTTP status code, HTTP response headers (array of strings)
     */
    public function lodgingBusinessWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\LodgingBusiness',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lodgingBusinessAsync
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->lodgingBusinessAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lodgingBusinessAsyncWithHttpInfo
     *
     * LodgingBusiness
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lodgingBusinessAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\LodgingBusiness';
        $request = $this->lodgingBusinessRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lodgingBusiness'
     *
     * @param  string $id Use property identifier of LodgingBusiness to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function lodgingBusinessRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lodgingBusiness'
            );
        }

        $resourcePath = '/lodgingbusinesses/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mediaObject
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\MediaObject
     */
    public function mediaObject($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->mediaObjectWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation mediaObjectWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\MediaObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function mediaObjectWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\MediaObject';
        $request = $this->mediaObjectRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\MediaObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mediaObjectAsync
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->mediaObjectAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mediaObjectAsyncWithHttpInfo
     *
     * MediaObject
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mediaObjectAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\MediaObject';
        $request = $this->mediaObjectRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mediaObject'
     *
     * @param  string $id Use property identifier of MediaObject to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mediaObjectRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling mediaObject'
            );
        }

        $resourcePath = '/mediaObjects/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation place
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Place
     */
    public function place($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->placeWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation placeWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Place, HTTP status code, HTTP response headers (array of strings)
     */
    public function placeWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Place';
        $request = $this->placeRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Place',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation placeAsync
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->placeAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation placeAsyncWithHttpInfo
     *
     * Place
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function placeAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Place';
        $request = $this->placeRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'place'
     *
     * @param  string $id Use property identifier of Place to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function placeRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling place'
            );
        }

        $resourcePath = '/places/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation product
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Product
     */
    public function product($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->productWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation productWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function productWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Product';
        $request = $this->productRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAsync
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->productAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAsyncWithHttpInfo
     *
     * Product
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Product';
        $request = $this->productRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'product'
     *
     * @param  string $id Use property identifier of Product to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function productRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling product'
            );
        }

        $resourcePath = '/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\ExtendedSearchRequest $body body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\SearchResponse
     */
    public function search($body = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchWithHttpInfo($body, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\ExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\SearchResponse';
        $request = $this->searchRequest($body, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\SearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\ExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($body = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchAsyncWithHttpInfo($body, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  \Infocenter\Client\Model\ExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($body = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\SearchResponse';
        $request = $this->searchRequest($body, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  \Infocenter\Client\Model\ExtendedSearchRequest $body (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($body = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchByGET
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\SearchResponse
     */
    public function searchByGET($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->searchByGETWithHttpInfo($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation searchByGETWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchByGETWithHttpInfo($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\SearchResponse';
        $request = $this->searchByGETRequest($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\SearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchByGETAsync
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsync($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        return $this->searchByGETAsyncWithHttpInfo($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchByGETAsyncWithHttpInfo
     *
     * Search by GET
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchByGETAsyncWithHttpInfo($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\SearchResponse';
        $request = $this->searchByGETRequest($search_text, $current_page, $results_per_page, $order_by, $filters, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchByGET'
     *
     * @param  string $search_text Use property for search request text (optional)
     * @param  int $current_page Format - int32. Use property to set number of page (optional)
     * @param  int $results_per_page Format - int32. Use property to set count of results per page (optional)
     * @param  string $order_by Use property for ordering (optional)
     * @param  string $filters Use property for odata filters (optional)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchByGETRequest($search_text = null, $current_page = null, $results_per_page = null, $order_by = null, $filters = null, $accept_language = null, $accept_timezone = null)
    {

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_text !== null) {
            $queryParams['searchText'] = ObjectSerializer::toQueryValue($search_text);
        }
        // query params
        if ($current_page !== null) {
            $queryParams['currentPage'] = ObjectSerializer::toQueryValue($current_page);
        }
        // query params
        if ($results_per_page !== null) {
            $queryParams['resultsPerPage'] = ObjectSerializer::toQueryValue($results_per_page);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($filters !== null) {
            $queryParams['filters'] = ObjectSerializer::toQueryValue($filters);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termVersion
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\TermVersion
     */
    public function termVersion($code, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->termVersionWithHttpInfo($code, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation termVersionWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\TermVersion, HTTP status code, HTTP response headers (array of strings)
     */
    public function termVersionWithHttpInfo($code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\TermVersion';
        $request = $this->termVersionRequest($code, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\TermVersion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation termVersionAsync
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsync($code, $accept_language = null, $accept_timezone = null)
    {
        return $this->termVersionAsyncWithHttpInfo($code, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termVersionAsyncWithHttpInfo
     *
     * TermVersion
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termVersionAsyncWithHttpInfo($code, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\TermVersion';
        $request = $this->termVersionRequest($code, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termVersion'
     *
     * @param  string $code Use property code of TermVersion to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termVersionRequest($code, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling termVersion'
            );
        }

        $resourcePath = '/termversions/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tour
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Tour
     */
    public function tour($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->tourWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation tourWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Tour, HTTP status code, HTTP response headers (array of strings)
     */
    public function tourWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Tour';
        $request = $this->tourRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Tour',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tourAsync
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->tourAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tourAsyncWithHttpInfo
     *
     * Tour
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tourAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Tour';
        $request = $this->tourRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tour'
     *
     * @param  string $id Use property identifier of Tour to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tourRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tour'
            );
        }

        $resourcePath = '/tours/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation treeAdministrativeAreaRegion
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\AdministrativeAreaTreeItem
     */
    public function treeAdministrativeAreaRegion($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        list($response) = $this->treeAdministrativeAreaRegionWithHttpInfo($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);
        return $response;
    }

    /**
     * Operation treeAdministrativeAreaRegionWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\AdministrativeAreaTreeItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function treeAdministrativeAreaRegionWithHttpInfo($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\AdministrativeAreaTreeItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation treeAdministrativeAreaRegionAsync
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsync($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        return $this->treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels, $admin_areas_only, $accept_timezone, $accept_language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation treeAdministrativeAreaRegionAsyncWithHttpInfo
     *
     * Tree AdministrativeArea (Region)
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function treeAdministrativeAreaRegionAsyncWithHttpInfo($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        $returnType = '\Infocenter\Client\Model\AdministrativeAreaTreeItem';
        $request = $this->treeAdministrativeAreaRegionRequest($id, $levels, $admin_areas_only, $accept_timezone, $accept_language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'treeAdministrativeAreaRegion'
     *
     * @param  string $id Use property identifier of Region to set root Region. (required)
     * @param  string $levels controls how deep the tree should go. default &#x3D; 1 (optional)
     * @param  string $admin_areas_only set to true all types of areas are included. This kind of destroys the tree structure and combined with high levels the performance is bad. default &#x3D; false (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     * @param  string $accept_language Localized properties. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function treeAdministrativeAreaRegionRequest($id, $levels = null, $admin_areas_only = null, $accept_timezone = null, $accept_language = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling treeAdministrativeAreaRegion'
            );
        }

        $resourcePath = '/areas/{id}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($levels !== null) {
            $queryParams['levels'] = ObjectSerializer::toQueryValue($levels);
        }
        // query params
        if ($admin_areas_only !== null) {
            $queryParams['adminAreasOnly'] = ObjectSerializer::toQueryValue($admin_areas_only);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }
        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation webcam
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Infocenter\Client\Model\Webcam
     */
    public function webcam($id, $accept_language = null, $accept_timezone = null)
    {
        list($response) = $this->webcamWithHttpInfo($id, $accept_language, $accept_timezone);
        return $response;
    }

    /**
     * Operation webcamWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \Infocenter\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Infocenter\Client\Model\Webcam, HTTP status code, HTTP response headers (array of strings)
     */
    public function webcamWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Webcam';
        $request = $this->webcamRequest($id, $accept_language, $accept_timezone);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Infocenter\Client\Model\Webcam',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation webcamAsync
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsync($id, $accept_language = null, $accept_timezone = null)
    {
        return $this->webcamAsyncWithHttpInfo($id, $accept_language, $accept_timezone)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation webcamAsyncWithHttpInfo
     *
     * Webcam
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function webcamAsyncWithHttpInfo($id, $accept_language = null, $accept_timezone = null)
    {
        $returnType = '\Infocenter\Client\Model\Webcam';
        $request = $this->webcamRequest($id, $accept_language, $accept_timezone);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'webcam'
     *
     * @param  string $id Use property identifier of Webcam to get single object. (required)
     * @param  string $accept_language Localized properties. (optional)
     * @param  string $accept_timezone Time zone ID for response dates and times (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function webcamRequest($id, $accept_language = null, $accept_timezone = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling webcam'
            );
        }

        $resourcePath = '/webcams/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept_language !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($accept_language);
        }
        // header params
        if ($accept_timezone !== null) {
            $headerParams['Accept-Timezone'] = ObjectSerializer::toHeaderValue($accept_timezone);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Ocp-Apim-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Ocp-Apim-Subscription-Key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
